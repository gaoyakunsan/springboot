/*!

 hlsjs engine plugin for Flowplayer HTML5

 Copyright (c) 2015-2016, Flowplayer Oy

 Released under the MIT License:
 http://www.opensource.org/licenses/mit-license.php

 Includes hls.js
 Copyright (c) 2015 Dailymotion (http://www.dailymotion.com)
 https://github.com/dailymotion/hls.js/blob/master/LICENSE

 Requires Flowplayer HTML5 version 6.x
 v1.0.1-6-gd587e3e

 */
/*@cc_on @*/
/*@
 @if (@_jscript_version > 10)
 @*/
!function (e) {
    function t(i) {
        if (r[i])return r[i].exports;
        var a = r[i] = {exports: {}, id: i, loaded: !1};
        return e[i].call(a.exports, a, a.exports, t), a.loaded = !0, a.exports
    }

    var r = {};
    return t.m = e, t.c = r, t.p = "", t(0)
}([function (e, t, r) {
    e.exports = r(51)
}, function (e, t) {
    "use strict";
    function r() {
    }

    function i(e, t) {
        return t = "[" + e + "] > " + t
    }

    function a(e) {
        var t = self.console[e];
        return t ? function () {
            for (var r = arguments.length, a = Array(r), n = 0; n < r; n++)a[n] = arguments[n];
            a[0] && (a[0] = i(e, a[0])), t.apply(self.console, a)
        } : r
    }

    function n(e) {
        for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i];
        r.forEach(function (t) {
            u[t] = e[t] ? e[t].bind(e) : a(t)
        })
    }

    var s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var o = "function" == typeof Symbol && "symbol" === s(Symbol.iterator) ? function (e) {
        return "undefined" == typeof e ? "undefined" : s(e)
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : "undefined" == typeof e ? "undefined" : s(e)
    }, l = {trace: r, debug: r, log: r, warn: r, info: r, error: r}, u = l;
    t.enableLogs = function (e) {
        if (e === !0 || "object" === ("undefined" == typeof e ? "undefined" : o(e))) {
            n(e, "debug", "log", "info", "warn", "error");
            try {
                u.log()
            } catch (e) {
                u = l
            }
        } else u = l
    }, t.logger = u
}, function (e, t) {
    "use strict";
    e.exports = {
        MEDIA_ATTACHING: "hlsMediaAttaching",
        MEDIA_ATTACHED: "hlsMediaAttached",
        MEDIA_DETACHING: "hlsMediaDetaching",
        MEDIA_DETACHED: "hlsMediaDetached",
        BUFFER_RESET: "hlsBufferReset",
        BUFFER_CODECS: "hlsBufferCodecs",
        BUFFER_CREATED: "hlsBufferCreated",
        BUFFER_APPENDING: "hlsBufferAppending",
        BUFFER_APPENDED: "hlsBufferAppended",
        BUFFER_EOS: "hlsBufferEos",
        BUFFER_FLUSHING: "hlsBufferFlushing",
        BUFFER_FLUSHED: "hlsBufferFlushed",
        MANIFEST_LOADING: "hlsManifestLoading",
        MANIFEST_LOADED: "hlsManifestLoaded",
        MANIFEST_PARSED: "hlsManifestParsed",
        LEVEL_LOADING: "hlsLevelLoading",
        LEVEL_LOADED: "hlsLevelLoaded",
        LEVEL_UPDATED: "hlsLevelUpdated",
        LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
        LEVEL_SWITCH: "hlsLevelSwitch",
        AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
        AUDIO_TRACK_SWITCH: "hlsAudioTrackSwitch",
        AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
        AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
        FRAG_LOADING: "hlsFragLoading",
        FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
        FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
        FRAG_LOADED: "hlsFragLoaded",
        FRAG_DECRYPTED: "hlsFragDecrypted",
        FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
        FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
        FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
        FRAG_PARSING_DATA: "hlsFragParsingData",
        FRAG_PARSED: "hlsFragParsed",
        FRAG_BUFFERED: "hlsFragBuffered",
        FRAG_CHANGED: "hlsFragChanged",
        FPS_DROP: "hlsFpsDrop",
        FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
        ERROR: "hlsError",
        DESTROYING: "hlsDestroying",
        KEY_LOADING: "hlsKeyLoading",
        KEY_LOADED: "hlsKeyLoaded",
        STREAM_STATE_TRANSITION: "hlsStreamStateTransition"
    }
}, function (e, t) {
    "use strict";
    Object.defineProperty(t, "__esModule", {value: !0});
    t.ErrorTypes = {
        NETWORK_ERROR: "networkError",
        MEDIA_ERROR: "mediaError",
        OTHER_ERROR: "otherError"
    }, t.ErrorDetails = {
        MANIFEST_LOAD_ERROR: "manifestLoadError",
        MANIFEST_LOAD_TIMEOUT: "manifestLoadTimeOut",
        MANIFEST_PARSING_ERROR: "manifestParsingError",
        MANIFEST_INCOMPATIBLE_CODECS_ERROR: "manifestIncompatibleCodecsError",
        LEVEL_LOAD_ERROR: "levelLoadError",
        LEVEL_LOAD_TIMEOUT: "levelLoadTimeOut",
        LEVEL_SWITCH_ERROR: "levelSwitchError",
        AUDIO_TRACK_LOAD_ERROR: "audioTrackLoadError",
        AUDIO_TRACK_LOAD_TIMEOUT: "audioTrackLoadTimeOut",
        FRAG_LOAD_ERROR: "fragLoadError",
        FRAG_LOOP_LOADING_ERROR: "fragLoopLoadingError",
        FRAG_LOAD_TIMEOUT: "fragLoadTimeOut",
        FRAG_DECRYPT_ERROR: "fragDecryptError",
        FRAG_PARSING_ERROR: "fragParsingError",
        KEY_LOAD_ERROR: "keyLoadError",
        KEY_LOAD_TIMEOUT: "keyLoadTimeOut",
        BUFFER_ADD_CODEC_ERROR: "bufferAddCodecError",
        BUFFER_APPEND_ERROR: "bufferAppendError",
        BUFFER_APPENDING_ERROR: "bufferAppendingError",
        BUFFER_STALLED_ERROR: "bufferStalledError",
        BUFFER_FULL_ERROR: "bufferFullError",
        BUFFER_SEEK_OVER_HOLE: "bufferSeekOverHole",
        INTERNAL_EXCEPTION: "internalException"
    }
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var s = "function" == typeof Symbol && "symbol" === n(Symbol.iterator) ? function (e) {
        return "undefined" == typeof e ? "undefined" : n(e)
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : "undefined" == typeof e ? "undefined" : n(e)
    }, o = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), l = r(1), u = r(3), d = r(2), f = i(d), c = function () {
        function e(t) {
            a(this, e), this.hls = t, this.onEvent = this.onEvent.bind(this);
            for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)i[n - 1] = arguments[n];
            this.handledEvents = i, this.useGenericHandler = !0, this.registerListeners()
        }

        return o(e, [{
            key: "destroy", value: function () {
                this.unregisterListeners()
            }
        }, {
            key: "isEventHandler", value: function () {
                return "object" === s(this.handledEvents) && this.handledEvents.length && "function" == typeof this.onEvent
            }
        }, {
            key: "registerListeners", value: function () {
                this.isEventHandler() && this.handledEvents.forEach(function (e) {
                    if ("hlsEventGeneric" === e)throw new Error("Forbidden event name: " + e);
                    this.hls.on(e, this.onEvent)
                }.bind(this))
            }
        }, {
            key: "unregisterListeners", value: function () {
                this.isEventHandler() && this.handledEvents.forEach(function (e) {
                    this.hls.off(e, this.onEvent)
                }.bind(this))
            }
        }, {
            key: "onEvent", value: function (e, t) {
                this.onEventGeneric(e, t)
            }
        }, {
            key: "onEventGeneric", value: function (e, t) {
                var r = function (e, t) {
                    var r = "on" + e.replace("hls", "");
                    if ("function" != typeof this[r])throw new Error("Event " + e + " has no generic handler in this " + this.constructor.name + " class (tried " + r + ")");
                    return this[r].bind(this, t)
                };
                try {
                    r.call(this, e, t).call()
                } catch (t) {
                    l.logger.error("internal error happened while processing " + e + ":" + t.message), this.hls.trigger(f.default.ERROR, {
                        type: u.ErrorTypes.OTHER_ERROR,
                        details: u.ErrorDetails.INTERNAL_EXCEPTION,
                        fatal: !1,
                        event: e,
                        err: t
                    })
                }
            }
        }]), e
    }();
    t.default = c
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e() {
            r(this, e)
        }

        return i(e, null, [{
            key: "isBuffered", value: function (e, t) {
                if (e)for (var r = e.buffered, i = 0; i < r.length; i++)if (t >= r.start(i) && t <= r.end(i))return !0;
                return !1
            }
        }, {
            key: "bufferInfo", value: function (e, t, r) {
                if (e) {
                    var i, a = e.buffered, n = [];
                    for (i = 0; i < a.length; i++)n.push({start: a.start(i), end: a.end(i)});
                    return this.bufferedInfo(n, t, r)
                }
                return {len: 0, start: 0, end: 0, nextStart: void 0}
            }
        }, {
            key: "bufferedInfo", value: function (e, t, r) {
                var i, a, n, s, o, l = [];
                for (e.sort(function (e, t) {
                    var r = e.start - t.start;
                    return r ? r : t.end - e.end
                }), o = 0; o < e.length; o++) {
                    var u = l.length;
                    if (u) {
                        var d = l[u - 1].end;
                        e[o].start - d < r ? e[o].end > d && (l[u - 1].end = e[o].end) : l.push(e[o])
                    } else l.push(e[o])
                }
                for (o = 0, i = 0, a = n = t; o < l.length; o++) {
                    var f = l[o].start, c = l[o].end;
                    if (t + r >= f && t < c)a = f, n = c, i = n - t; else if (t + r < f) {
                        s = f;
                        break
                    }
                }
                return {len: i, start: a, end: n, nextStart: s}
            }
        }]), e
    }();
    t.default = a
}, function (e, t, r) {
    "use strict";
    function i(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var a = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), n = r(1), s = r(3), o = function () {
        function e() {
            i(this, e)
        }

        return a(e, null, [{
            key: "getAudioConfig", value: function (e, t, r, i) {
                var a, o, l, u, d, f = navigator.userAgent.toLowerCase(), c = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                return a = ((192 & t[r + 2]) >>> 6) + 1, o = (60 & t[r + 2]) >>> 2, o > c.length - 1 ? void e.trigger(Event.ERROR, {
                    type: s.ErrorTypes.MEDIA_ERROR,
                    details: s.ErrorDetails.FRAG_PARSING_ERROR,
                    fatal: !0,
                    reason: "invalid ADTS sampling index:" + o
                }) : (u = (1 & t[r + 2]) << 2, u |= (192 & t[r + 3]) >>> 6, n.logger.log("manifest codec:" + i + ",ADTS data:type:" + a + ",sampleingIndex:" + o + "[" + c[o] + "Hz],channelConfig:" + u), /firefox|OPR/i.test(f) ? o >= 6 ? (a = 5, d = new Array(4), l = o - 3) : (a = 2, d = new Array(2), l = o) : f.indexOf("android") !== -1 ? (a = 2, d = new Array(2), l = o) : (a = 5, d = new Array(4), i && (i.indexOf("mp4a.40.29") !== -1 || i.indexOf("mp4a.40.5") !== -1) || !i && o >= 6 ? l = o - 3 : ((i && i.indexOf("mp4a.40.2") !== -1 && o >= 6 && 1 === u || !i && 1 === u) && (a = 2, d = new Array(2)), l = o)), d[0] = a << 3, d[0] |= (14 & o) >> 1, d[1] |= (1 & o) << 7, d[1] |= u << 3, 5 === a && (d[1] |= (14 & l) >> 1, d[2] = (1 & l) << 7, d[2] |= 8, d[3] = 0), {
                    config: d,
                    samplerate: c[o],
                    channelCount: u,
                    codec: "mp4a.40." + a
                })
            }
        }]), e
    }();
    t.default = o
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(2), o = i(s), l = r(3), u = r(28), d = i(u), f = r(32), c = i(f), h = r(40), v = i(h), g = r(41), p = i(g), y = function () {
        function e(t, r, i) {
            var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            a(this, e), this.hls = t, this.id = r, this.config = this.hls.config || n, this.typeSupported = i
        }

        return n(e, [{
            key: "destroy", value: function () {
                var e = this.demuxer;
                e && e.destroy()
            }
        }, {
            key: "push", value: function (e, t, r, i, a, n, s, u, f) {
                var h = this.demuxer;
                if (!h) {
                    var g = this.hls, y = this.id;
                    if (c.default.probe(e))h = this.typeSupported.mp2t === !0 ? new c.default(g, y, p.default, this.config) : new c.default(g, y, v.default, this.config); else {
                        if (!d.default.probe(e))return void g.trigger(o.default.ERROR, {
                            type: l.ErrorTypes.MEDIA_ERROR,
                            id: y,
                            details: l.ErrorDetails.FRAG_PARSING_ERROR,
                            fatal: !0,
                            reason: "no demux matching with content found"
                        });
                        h = new d.default(g, y, v.default, this.config)
                    }
                    this.demuxer = h
                }
                h.push(e, t, r, i, a, n, s, u, f)
            }
        }]), e
    }();
    t.default = y
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(2), o = i(s), l = r(7), u = i(l), d = r(29), f = i(d), c = r(1), h = r(26), v = i(h), g = r(3), p = function () {
        function e(t, i) {
            a(this, e), this.hls = t, this.id = i;
            var n = {
                mp4: MediaSource.isTypeSupported("video/mp4"),
                mp2t: t.config.enableMP2TPassThrough && MediaSource.isTypeSupported("video/mp2t")
            };
            if (t.config.enableWorker && "undefined" != typeof Worker) {
                c.logger.log("demuxing in webworker");
                var s = void 0;
                try {
                    var l = r(50);
                    s = this.w = l(f.default), this.onwmsg = this.onWorkerMessage.bind(this), s.addEventListener("message", this.onwmsg), s.onerror = function (e) {
                        t.trigger(o.default.ERROR, {
                            type: g.ErrorTypes.OTHER_ERROR,
                            details: g.ErrorDetails.INTERNAL_EXCEPTION,
                            fatal: !0,
                            event: "demuxerWorker",
                            err: {message: e.message + " (" + e.filename + ":" + e.lineno + ")"}
                        })
                    }, s.postMessage({cmd: "init", typeSupported: n, id: i, config: JSON.stringify(t.config)})
                } catch (e) {
                    c.logger.error("error while initializing DemuxerWorker, fallback on DemuxerInline"), s && URL.revokeObjectURL(s.objectURL), this.demuxer = new u.default(t, i, n)
                }
            } else this.demuxer = new u.default(t, i, n);
            this.demuxInitialized = !0
        }

        return n(e, [{
            key: "destroy", value: function () {
                var e = this.w;
                if (e)e.removeEventListener("message", this.onwmsg), e.terminate(), this.w = null; else {
                    var t = this.demuxer;
                    t && (t.destroy(), this.demuxer = null)
                }
                var r = this.decrypter;
                r && (r.destroy(), this.decrypter = null)
            }
        }, {
            key: "pushDecrypted", value: function (e, t, r, i, a, n, s, o, l) {
                var u = this.w;
                if (u)u.postMessage({
                    cmd: "demux",
                    data: e,
                    audioCodec: t,
                    videoCodec: r,
                    timeOffset: i,
                    cc: a,
                    level: n,
                    sn: s,
                    duration: o,
                    accurateTimeOffset: l
                }, [e]); else {
                    var d = this.demuxer;
                    d && d.push(new Uint8Array(e), t, r, i, a, n, s, o, l)
                }
            }
        }, {
            key: "push", value: function (e, t, r, i, a, n, s, l, u, d) {
                if (e.byteLength > 0 && null != u && null != u.key && "AES-128" === u.method) {
                    null == this.decrypter && (this.decrypter = new v.default(this.hls));
                    var f = this, c = performance.now();
                    this.decrypter.decrypt(e, u.key.buffer, u.iv.buffer, function (e) {
                        f.hls.trigger(o.default.FRAG_DECRYPTED, {
                            level: n,
                            sn: s,
                            stats: {tstart: c, tdecrypt: performance.now()}
                        }), f.pushDecrypted(e, t, r, i, a, n, s, l, d)
                    })
                } else this.pushDecrypted(e, t, r, i, a, n, s, l, d)
            }
        }, {
            key: "onWorkerMessage", value: function (e) {
                var t = e.data, r = this.hls;
                switch (t.event) {
                    case"init":
                        URL.revokeObjectURL(this.w.objectURL);
                        break;
                    case o.default.FRAG_PARSING_DATA:
                        t.data.data1 = new Uint8Array(t.data1), t.data.data2 = new Uint8Array(t.data2);
                    default:
                        r.trigger(t.event, t.data)
                }
            }
        }]), e
    }();
    t.default = p
}, function (e, t, r) {
    "use strict";
    function i(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var a = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), n = r(1), s = function () {
        function e() {
            i(this, e)
        }

        return a(e, null, [{
            key: "mergeDetails", value: function (t, r) {
                var i, a = Math.max(t.startSN, r.startSN) - r.startSN, s = Math.min(t.endSN, r.endSN) - r.startSN, o = r.startSN - t.startSN, l = t.fragments, u = r.fragments, d = 0;
                if (s < a)return void(r.PTSKnown = !1);
                for (var f = a; f <= s; f++) {
                    var c = l[o + f], h = u[f];
                    h && c && (d = c.cc - h.cc, isNaN(c.startPTS) || (h.start = h.startPTS = c.startPTS, h.endPTS = c.endPTS, h.duration = c.duration, i = h))
                }
                if (d)for (n.logger.log("discontinuity sliding from playlist, take drift into account"), f = 0; f < u.length; f++)u[f].cc += d;
                if (i)e.updateFragPTSDTS(r, i.sn, i.startPTS, i.endPTS, i.startDTS, i.endDTS); else if (o >= 0 && o < l.length) {
                    var v = l[o].start;
                    for (f = 0; f < u.length; f++)u[f].start += v
                }
                r.PTSKnown = t.PTSKnown
            }
        }, {
            key: "updateFragPTSDTS", value: function (t, r, i, a, n, s) {
                var o, l, u, d;
                if (r < t.startSN || r > t.endSN)return 0;
                if (o = r - t.startSN, l = t.fragments, u = l[o], !isNaN(u.startPTS)) {
                    var f = Math.abs(u.startPTS - i);
                    isNaN(u.deltaPTS) ? u.deltaPTS = f : u.deltaPTS = Math.max(f, u.deltaPTS), i = Math.min(i, u.startPTS), a = Math.max(a, u.endPTS), n = Math.min(n, u.startDTS), s = Math.max(s, u.endDTS)
                }
                var c = i - u.start;
                for (u.start = u.startPTS = i, u.endPTS = a, u.startDTS = n, u.endDTS = s, u.duration = a - i, d = o; d > 0; d--)e.updatePTS(l, d, d - 1);
                for (d = o; d < l.length - 1; d++)e.updatePTS(l, d, d + 1);
                return t.PTSKnown = !0, c
            }
        }, {
            key: "updatePTS", value: function (e, t, r) {
                var i = e[t], a = e[r], s = a.startPTS;
                isNaN(s) ? r > t ? a.start = i.start + i.duration : a.start = i.start - a.duration : r > t ? (i.duration = s - i.start, i.duration < 0 && n.logger.warn("negative duration computed for frag " + i.sn + ",level " + i.level + ", there should be some duration drift between playlist and fragment!")) : (a.duration = i.start - s, a.duration < 0 && n.logger.warn("negative duration computed for frag " + a.sn + ",level " + a.level + ", there should be some duration drift between playlist and fragment!"))
            }
        }]), e
    }();
    t.default = s
}, function (e, t) {
    "use strict";
    var r = {
        search: function (e, t) {
            for (var r = 0, i = e.length - 1, a = null, n = null; r <= i;) {
                a = (r + i) / 2 | 0, n = e[a];
                var s = t(n);
                if (s > 0)r = a + 1; else {
                    if (!(s < 0))return n;
                    i = a - 1
                }
            }
            return null
        }
    };
    e.exports = r
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e() {
            r(this, e)
        }

        return i(e, null, [{
            key: "toString", value: function (e) {
                for (var t = "", r = e.length, i = 0; i < r; i++)t += "[" + e.start(i).toFixed(3) + "," + e.end(i).toFixed(3) + "]";
                return t
            }
        }]), e
    }();
    t.default = a
}, function (e, t) {
    function r() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0
    }

    function i(e) {
        return "function" == typeof e
    }

    function a(e) {
        return "number" == typeof e
    }

    function n(e) {
        return "object" == typeof e && null !== e
    }

    function s(e) {
        return void 0 === e
    }

    e.exports = r, r.EventEmitter = r, r.prototype._events = void 0, r.prototype._maxListeners = void 0, r.defaultMaxListeners = 10, r.prototype.setMaxListeners = function (e) {
        if (!a(e) || e < 0 || isNaN(e))throw TypeError("n must be a positive number");
        return this._maxListeners = e, this
    }, r.prototype.emit = function (e) {
        var t, r, a, o, l, u;
        if (this._events || (this._events = {}), "error" === e && (!this._events.error || n(this._events.error) && !this._events.error.length)) {
            if (t = arguments[1], t instanceof Error)throw t;
            var d = new Error('Uncaught, unspecified "error" event. (' + t + ")");
            throw d.context = t, d
        }
        if (r = this._events[e], s(r))return !1;
        if (i(r))switch (arguments.length) {
            case 1:
                r.call(this);
                break;
            case 2:
                r.call(this, arguments[1]);
                break;
            case 3:
                r.call(this, arguments[1], arguments[2]);
                break;
            default:
                o = Array.prototype.slice.call(arguments, 1), r.apply(this, o)
        } else if (n(r))for (o = Array.prototype.slice.call(arguments, 1), u = r.slice(), a = u.length, l = 0; l < a; l++)u[l].apply(this, o);
        return !0
    }, r.prototype.addListener = function (e, t) {
        var a;
        if (!i(t))throw TypeError("listener must be a function");
        return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", e, i(t.listener) ? t.listener : t), this._events[e] ? n(this._events[e]) ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, n(this._events[e]) && !this._events[e].warned && (a = s(this._maxListeners) ? r.defaultMaxListeners : this._maxListeners, a && a > 0 && this._events[e].length > a && (this._events[e].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[e].length), "function" == typeof console.trace && console.trace())), this
    }, r.prototype.on = r.prototype.addListener, r.prototype.once = function (e, t) {
        function r() {
            this.removeListener(e, r), a || (a = !0, t.apply(this, arguments))
        }

        if (!i(t))throw TypeError("listener must be a function");
        var a = !1;
        return r.listener = t, this.on(e, r), this
    }, r.prototype.removeListener = function (e, t) {
        var r, a, s, o;
        if (!i(t))throw TypeError("listener must be a function");
        if (!this._events || !this._events[e])return this;
        if (r = this._events[e], s = r.length, a = -1, r === t || i(r.listener) && r.listener === t)delete this._events[e], this._events.removeListener && this.emit("removeListener", e, t); else if (n(r)) {
            for (o = s; o-- > 0;)if (r[o] === t || r[o].listener && r[o].listener === t) {
                a = o;
                break
            }
            if (a < 0)return this;
            1 === r.length ? (r.length = 0, delete this._events[e]) : r.splice(a, 1), this._events.removeListener && this.emit("removeListener", e, t)
        }
        return this
    }, r.prototype.removeAllListeners = function (e) {
        var t, r;
        if (!this._events)return this;
        if (!this._events.removeListener)return 0 === arguments.length ? this._events = {} : this._events[e] && delete this._events[e], this;
        if (0 === arguments.length) {
            for (t in this._events)"removeListener" !== t && this.removeAllListeners(t);
            return this.removeAllListeners("removeListener"), this._events = {}, this
        }
        if (r = this._events[e], i(r))this.removeListener(e, r); else if (r)for (; r.length;)this.removeListener(e, r[r.length - 1]);
        return delete this._events[e], this
    }, r.prototype.listeners = function (e) {
        var t;
        return t = this._events && this._events[e] ? i(this._events[e]) ? [this._events[e]] : this._events[e].slice() : []
    }, r.prototype.listenerCount = function (e) {
        if (this._events) {
            var t = this._events[e];
            if (i(t))return 1;
            if (t)return t.length
        }
        return 0
    }, r.listenerCount = function (e, t) {
        return e.listenerCount(t)
    }
}, function (e, t, r) {
    !function () {
        "use strict";
        var t = function (e, t) {
            var r, i = "hlsjs", a = t.common, n = t.extend, s = t.support, o = t.version, l = window.performance, u = function (e) {
                return e.toLowerCase().indexOf("mpegurl") > -1
            }, d = function (e) {
                var t = e.clip && e.clip.hlsQualities || e.hlsQualities;
                return s.inlineVideo && (t === !0 || t && t.length)
            }, f = function (s, f) {
                var c, h, v, g, p, y, m, E = t.bean, b = "is-seeking", k = function (e, t, r) {
                    if (e.debug && console.log("recovery." + i, "<-", t), a.removeClass(f, "is-paused"), a.addClass(f, b), r)h.startLoad(); else {
                        var n = l.now();
                        if (!g || n - g > 3e3)g = l.now(), h.recoverMediaError(); else {
                            if (p && !(n - p > 3e3))return 3;
                            p = l.now(), h.swapAudioCodec(), h.recoverMediaError()
                        }
                    }
                    v > 0 && (v -= 1)
                }, R = "is-poster", _ = function () {
                    E.one(c, "timeupdate." + i, function () {
                        a.addClass(f, R), s.poster = !0
                    })
                }, S = function () {
                    s.poster && E.one(c, "timeupdate." + i, function () {
                        a.removeClass(f, R), s.poster = !1
                    })
                }, T = !1, A = 0, L = function () {
                    h.startLoad(h.config.startPosition)
                }, w = "active", D = function (e) {
                    return e || (e = s.quality), e.toLowerCase().replace(/\ /g, "")
                }, O = function () {
                    var e = s.qualities;
                    e && e.length && (a.removeClass(f, "quality-abr"), e.forEach(function (e) {
                        a.removeClass(f, "quality-" + D(e))
                    }))
                }, P = function () {
                    delete s.hlsQualities, O(), a.find(".fp-quality-selector", f).forEach(a.removeNode)
                }, C = function () {
                    return s.hlsQualities[s.qualities.indexOf(s.quality) + 1]
                }, I = function (e, t, r) {
                    var n, o = r.levels, l = [], u = [], d = 0;
                    if (P(), "drive" === e)switch (o.length) {
                        case 4:
                            l = [1, 2, 3];
                            break;
                        case 5:
                            l = [1, 2, 3, 4];
                            break;
                        case 6:
                            l = [1, 3, 4, 5];
                            break;
                        case 7:
                            l = [1, 3, 5, 6];
                            break;
                        case 8:
                            l = [1, 3, 6, 7];
                            break;
                        default:
                            if (o.length < 3 || o[0].height && o[2].height && o[0].height === o[2].height)return;
                            l = [1, 2]
                    } else if ("string" == typeof e ? e.split(/\s*,\s*/).forEach(function (e) {
                            u.push(parseInt(e, 10))
                        }) : "boolean" != typeof e && e.forEach(function (e) {
                            u.push("number" == typeof e ? e : e.level)
                        }), o.forEach(function (t) {
                            (e === !0 || u.indexOf(d) > -1) && (!t.videoCodec || t.videoCodec && window.MediaSource.isTypeSupported("video/mp4;codecs=" + t.videoCodec)) && l.push(d), d += 1
                        }), l.length < 2)return;
                    s.qualities = [], l.forEach(function (t) {
                        var r = o[t], i = r.width, a = r.height, n = u.length ? e[u.indexOf(t)] : t, l = "object" == typeof n ? n.label : i && a ? Math.min(i, a) + "p" : "Level " + (t + 1);
                        s.qualities.push(l)
                    }), n = a.createElement("ul", {class: "fp-quality-selector"}), a.find(".fp-ui", f)[0].appendChild(n), l.unshift(-1), s.hlsQualities = l, !s.quality || s.qualities.indexOf(s.quality) < 0 ? s.quality = "abr" : (h.startLevel = C(), h.loadLevel = h.startLevel), n.appendChild(a.createElement("li", {"data-quality": "abr"}, "Auto")), s.qualities.forEach(function (e) {
                        n.appendChild(a.createElement("li", {"data-quality": D(e)}, e))
                    }), a.addClass(f, "quality-" + D()), E.on(f, "click." + i, ".fp-quality-selector li", function (e) {
                        var r, n, o, l = e.currentTarget, u = t.smoothSwitching, d = c.paused;
                        if (!a.hasClass(l, w)) {
                            for (d || u || E.one(c, "pause." + i, function () {
                                a.removeClass(f, "is-paused")
                            }), r = a.find(".fp-quality-selector li", f), o = 0; o < r.length; o += 1)n = r[o] === l, n && (s.quality = o > 0 ? s.qualities[o - 1] : "abr", u && !s.poster ? h.nextLevel = C() : h.currentLevel = C(), a.addClass(l, w), d && c.play()), a.toggleClass(r[o], w, n);
                            O(), a.addClass(f, "quality-" + D())
                        }
                    })
                }, x = {
                    engineName: i, pick: function (e) {
                        var t, r;
                        for (t = 0; t < e.length; t += 1)if (r = e[t], u(r.type))return "string" == typeof r.src && (r.src = a.createAbsoluteUrl(r.src)), r
                    }, load: function (t) {
                        var o = s.conf, l = {
                            ended: "finish",
                            loadeddata: "ready",
                            pause: "pause",
                            play: "resume",
                            progress: "buffer",
                            ratechange: "speed",
                            seeked: "seek",
                            timeupdate: "progress",
                            volumechange: "volume",
                            error: "error"
                        }, u = e.Events, y = !!t.autoplay || !!o.autoplay, m = t.hlsQualities || o.hlsQualities, R = n(r, o.hlsjs, o.clip.hlsjs, t.hlsjs), D = n({}, R);
                        t.hlsQualities === !1 && (m = !1), h ? (h.destroy(), (s.video.src && t.src !== s.video.src || t.index) && a.attr(c, "autoplay", "autoplay")) : (a.removeNode(a.findDirect("video", f)[0] || a.find(".fp-player > video", f)[0]), c = a.createElement("video", {
                            class: "fp-engine " + i + "-engine",
                            autoplay: !!y && "autoplay",
                            volume: s.volumeLevel,
                            "x-webkit-airplay": "allow"
                        }), Object.keys(l).forEach(function (e) {
                            var r, d = l[e], v = e + "." + i;
                            E.on(c, v, function (e) {
                                if (o.debug && d.indexOf("progress") < 0 && console.log(v, "->", d, e.originalEvent), s.ready || !(d.indexOf("ready") < 0)) {
                                    var l, g, p, y, m = c.currentTime, b = 0, _ = 0, L = s.video, D = L.src, O = !1, P = L.loop, C = s.quality;
                                    switch (d) {
                                        case"ready":
                                            r = n(L, {
                                                duration: c.duration,
                                                seekable: c.seekable.end(null),
                                                width: c.videoWidth,
                                                height: c.videoHeight,
                                                url: D
                                            });
                                            break;
                                        case"resume":
                                            S();
                                            break;
                                        case"seek":
                                            S(), r = m;
                                            break;
                                        case"progress":
                                            r = m;
                                            break;
                                        case"speed":
                                            r = c.playbackRate;
                                            break;
                                        case"volume":
                                            r = c.volume;
                                            break;
                                        case"buffer":
                                            try {
                                                if (l = c.buffered, b = l.end(null), m)for (g = l.length - 1; g > -1; g -= 1)_ = l.end(g), _ >= m && (b = _)
                                            } catch (e) {
                                            }
                                            t.buffer = b, r = b;
                                            break;
                                        case"finish":
                                            h.autoLevelEnabled && (P || o.playlist.length < 2 || o.advance === !1) && (O = !h.levels[A].details, O || h.levels[A].details.fragments.forEach(function (e) {
                                                O = !!O || !e.loadCounter
                                            }), O && (h.trigger(u.BUFFER_FLUSHING, {
                                                startOffset: 0,
                                                endOffset: .9 * L.duration
                                            }), P && E.one(c, "pause." + i, function () {
                                                a.removeClass(f, "is-paused")
                                            }), E.one(c, (P ? "play." : "timeupdate.") + i, function () {
                                                var e = h.currentLevel;
                                                e < A && (h.currentLevel = A, T = !0)
                                            })));
                                            break;
                                        case"error":
                                            y = c.error.code, (R.recoverMediaError && 3 === y || R.recoverNetworkError && 2 === y || R.recover && (2 === y || 3 === y)) && (y = k(o, d, 2 === y)), void 0 !== y ? (r = {code: y}, y > 2 && (r.video = n(L, {
                                                src: D,
                                                url: D
                                            }))) : r = !1
                                    }
                                    if (r === !1)return r;
                                    s.trigger(d, [s, r]), "ready" === d && C && (p = "abr" === C ? 0 : s.qualities.indexOf(C) + 1, a.addClass(a.find(".fp-quality-selector li", f)[p], w))
                                }
                            })
                        }), o.poster && (s.on("stop." + i, _), !s.live || y || s.video.autoplay || E.one(c, "seeked." + i, _)), s.on("error." + i, function () {
                            h && (h.destroy(), h = 0)
                        }), a.prepend(a.find(".fp-player", f)[0], c)), s.video = t, A = 0, T = !1, Object.keys(R).forEach(function (t) {
                            e.DefaultConfig.hasOwnProperty(t) || delete D[t];
                            var r = R[t];
                            switch (t) {
                                case"adaptOnStartOnly":
                                    r && (D.startLevel = -1);
                                    break;
                                case"autoLevelCapping":
                                    r === !1 && (r = -1), D[t] = r;
                                    break;
                                case"startLevel":
                                    switch (r) {
                                        case"auto":
                                            r = -1;
                                            break;
                                        case"firstLevel":
                                            r = void 0
                                    }
                                    D[t] = r;
                                    break;
                                case"recover":
                                    R.recoverMediaError = !1, R.recoverNetworkError = !1, v = r;
                                    break;
                                case"strict":
                                    r && (R.recoverMediaError = !1, R.recoverNetworkError = !1, v = 0)
                            }
                        }), D.autoStartLoad = !1, h = new e(D), s.engine[i] = h, g = null, p = null, Object.keys(u).forEach(function (t) {
                            var r = u[t], l = R.listeners, g = l && l.indexOf(r) > -1;
                            h.on(r, function (r, l) {
                                var u, p = {}, y = e.ErrorTypes, _ = e.ErrorDetails, S = s.video, w = S.src;
                                switch (t) {
                                    case"MEDIA_ATTACHED":
                                        h.loadSource(w);
                                        break;
                                    case"MANIFEST_PARSED":
                                        d(o) ? m ? I(m, R, l) : P() : delete s.quality, s.live ? L() : setTimeout(L);
                                        break;
                                    case"FRAG_LOADED":
                                        T ? (h.nextLevel = -1, T = !1, A = 0) : !s.live && h.autoLevelEnabled && h.loadLevel > A && (A = h.loadLevel);
                                        break;
                                    case"ERROR":
                                        if (l.fatal || R.strict) {
                                            switch (l.type) {
                                                case y.NETWORK_ERROR:
                                                    R.recoverNetworkError || v ? k(o, l.type, !0) : l.frag && l.frag.url ? (p.url = l.frag.url, u = 2) : u = 4;
                                                    break;
                                                case y.MEDIA_ERROR:
                                                    u = R.recoverMediaError || v ? k(o, l.type) : 3;
                                                    break;
                                                default:
                                                    h.destroy(), u = 5
                                            }
                                            void 0 !== u && (p.code = u, u > 2 && (p.video = n(S, {
                                                src: w,
                                                url: l.url || w
                                            })), s.trigger("error", [s, p]))
                                        } else switch (l.details) {
                                            case _.BUFFER_STALLED_ERROR:
                                            case _.FRAG_LOOP_LOADING_ERROR:
                                                a.addClass(f, b), E.one(c, "timeupdate." + i, function () {
                                                    a.removeClass(f, b)
                                                })
                                        }
                                }
                                g && s.trigger(r, [s, l])
                            })
                        }), R.adaptOnStartOnly && E.one(c, "timeupdate." + i, function () {
                            h.loadLevel = h.loadLevel
                        }), h.attachMedia(c), c.paused && y && c.play()
                    }, resume: function () {
                        c.play()
                    }, pause: function () {
                        c.pause()
                    }, seek: function (e) {
                        c.currentTime = e
                    }, volume: function (e) {
                        c && (c.volume = e)
                    }, speed: function (e) {
                        c.playbackRate = e, s.trigger("speed", [s, e])
                    }, unload: function () {
                        if (h) {
                            var e = "." + i;
                            h.destroy(), h = 0, P(), s.off(e), E.off(f, e), E.off(c, e), a.removeNode(c), c = 0
                        }
                    }
                };
                return !/^6\.0\.[0-3]$/.test(o) || s.conf.splash || s.conf.poster || s.conf.autoplay || (y = a.css(f, "backgroundColor"), m = "none" !== a.css(f, "backgroundImage") || y && "rgba(0, 0, 0, 0)" !== y && "transparent" !== y, m && (s.conf.poster = !0)), x
            };
            e.isSupported() && 0 !== o.indexOf("5.") && (f.engineName = i, f.canPlay = function (e, a) {
                var o = s.browser, l = window.navigator, d = l.userAgent.indexOf("Trident/7") > -1;
                return a[i] !== !1 && a.clip[i] !== !1 && (r = n({
                        smoothSwitching: !0,
                        recoverMediaError: !0
                    }, t.conf[i], a[i], a.clip[i]), !!u(e) && (!!r.debug || (!r.anamorphic || 0 !== l.platform.indexOf("Win") || !o.mozilla || 0 !== o.version.indexOf("44.")) && (d || !o.safari)))
            }, t.engines.unshift(f), t(function (e) {
                e.pluginQualitySelectorEnabled = d(e.conf) && f.canPlay("application/x-mpegurl", e.conf)
            }))
        };
        "object" == typeof e && e.exports ? e.exports = t.bind(void 0, r(35)) : window.Hls && window.flowplayer && t(window.Hls, window.flowplayer)
    }()
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = r(5), v = i(h), g = r(3), p = r(1), y = r(19), m = i(y), E = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.FRAG_LOADING, d.default.FRAG_LOADED, d.default.FRAG_BUFFERED, d.default.ERROR));
            return r.lastLoadedFragLevel = 0, r._autoLevelCapping = -1, r._nextAutoLevel = -1, r.hls = e, r.onCheck = r.abandonRulesCheck.bind(r), r
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                this.clearTimer(), c.default.prototype.destroy.call(this)
            }
        }, {
            key: "onFragLoading", value: function (e) {
                var t = e.frag;
                if ("main" === t.type) {
                    if (this.timer || (this.timer = setInterval(this.onCheck, 100)), !this.bwEstimator) {
                        var r = this.hls, i = e.frag.level, a = r.levels[i].details.live, n = r.config, s = void 0, o = void 0;
                        a ? (s = n.abrEwmaFastLive, o = n.abrEwmaSlowLive) : (s = n.abrEwmaFastVoD, o = n.abrEwmaSlowVoD), this.bwEstimator = new m.default(r, o, s, n.abrEwmaDefaultEstimate)
                    }
                    this.fragCurrent = t
                }
            }
        }, {
            key: "abandonRulesCheck", value: function () {
                var e = this.hls, t = e.media, r = this.fragCurrent, i = r.loader;
                if (!i || i.stats && i.stats.aborted)return p.logger.warn("frag loader destroy or aborted, disarm abandonRules"), void this.clearTimer();
                var a = i.stats;
                if (t && (!t.paused && 0 !== t.playbackRate || !t.readyState) && r.autoLevel && r.level) {
                    var n = performance.now() - a.trequest, s = Math.abs(t.playbackRate);
                    if (n > 500 * r.duration / s) {
                        var o = e.levels, l = Math.max(1, a.bw ? a.bw / 8 : 1e3 * a.loaded / n), u = a.total ? a.total : Math.max(a.loaded, Math.round(r.duration * o[r.level].bitrate / 8)), f = t.currentTime, c = (u - a.loaded) / l, h = (v.default.bufferInfo(t, f, e.config.maxBufferHole).end - f) / s;
                        if (h < 2 * r.duration / s && c > h) {
                            var g = void 0, y = void 0;
                            for (y = r.level - 1; y >= 0 && (g = r.duration * o[y].bitrate / (6.4 * l), !(g < h)); y--);
                            g < c && (y = Math.max(0, y), p.logger.warn("loading too slow, abort fragment loading and switch to level " + y + ":fragLoadedDelay[" + y + "]<fragLoadedDelay[" + (r.level - 1) + "];bufferStarvationDelay:" + g.toFixed(1) + "<" + c.toFixed(1) + ":" + h.toFixed(1)), e.nextLoadLevel = y, this.bwEstimator.sample(n, a.loaded), i.abort(), this.clearTimer(), e.trigger(d.default.FRAG_LOAD_EMERGENCY_ABORTED, {
                                frag: r,
                                stats: a
                            }))
                        }
                    }
                }
            }
        }, {
            key: "onFragLoaded", value: function (e) {
                var t = e.frag;
                if ("main" === t.type && (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, e.frag.bitrateTest)) {
                    var r = e.stats;
                    r.tparsed = r.tbuffered = r.tload, this.onFragBuffered(e)
                }
            }
        }, {
            key: "onFragBuffered", value: function (e) {
                var t = e.stats, r = e.frag;
                if (t.aborted !== !0 && 1 === r.loadCounter && "main" === r.type && (!r.bitrateTest || t.tload === t.tbuffered)) {
                    var i = t.tbuffered - t.trequest;
                    p.logger.log("latency/loading/parsing/append/kbps:" + Math.round(t.tfirst - t.trequest) + "/" + Math.round(t.tload - t.tfirst) + "/" + Math.round(t.tparsed - t.tload) + "/" + Math.round(t.tbuffered - t.tparsed) + "/" + Math.round(8 * t.loaded / (t.tbuffered - t.trequest))),
                        this.bwEstimator.sample(i, t.loaded), r.bitrateTest ? this.bitrateTestDelay = i / 1e3 : this.bitrateTestDelay = 0
                }
            }
        }, {
            key: "onError", value: function (e) {
                switch (e.details) {
                    case g.ErrorDetails.FRAG_LOAD_ERROR:
                    case g.ErrorDetails.FRAG_LOAD_TIMEOUT:
                        this.clearTimer()
                }
            }
        }, {
            key: "clearTimer", value: function () {
                this.timer && (clearInterval(this.timer), this.timer = null)
            }
        }, {
            key: "findBestLevel", value: function (e, t, r, i, a, n, s, o, l) {
                for (var u = a; u >= i; u--) {
                    var d = l[u], f = d.details, c = f ? f.totalduration / f.fragments.length : t, h = !!f && f.live, v = void 0;
                    v = u <= e ? s * r : o * r;
                    var g = l[u].bitrate, y = g * c / v;
                    if (p.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + u + "/" + Math.round(v) + "/" + g + "/" + c + "/" + n + "/" + y), v > g && (!y || h || y < n))return u
                }
                return -1
            }
        }, {
            key: "autoLevelCapping", get: function () {
                return this._autoLevelCapping
            }, set: function (e) {
                this._autoLevelCapping = e
            }
        }, {
            key: "nextAutoLevel", get: function () {
                var e = this._nextAutoLevel, t = this.bwEstimator, r = this.hls, i = r.levels, a = r.config.minAutoBitrate;
                if (!(e === -1 || t && t.canEstimate()))return Math.min(e, this.maxAutoLevel);
                var n = this.nextABRAutoLevel;
                if (e !== -1 && (n = Math.min(e, n)), void 0 !== a)for (; i[n].bitrate < a;)n++;
                return n
            }, set: function (e) {
                this._nextAutoLevel = e
            }
        }, {
            key: "minAutoLevel", get: function () {
                for (var e = this.hls, t = e.levels, r = e.config.minAutoBitrate, i = 0; i < t.length; i++)if (t[i].bitrate > r)return i;
                return 0
            }
        }, {
            key: "maxAutoLevel", get: function () {
                var e, t = this.hls.levels, r = this._autoLevelCapping;
                return e = r === -1 && t && t.length ? t.length - 1 : r
            }
        }, {
            key: "nextABRAutoLevel", get: function () {
                var e = this.hls, t = this.maxAutoLevel, r = e.levels, i = e.config, a = this.minAutoLevel, n = e.media, s = this.lastLoadedFragLevel, o = this.fragCurrent ? this.fragCurrent.duration : 0, l = n ? n.currentTime : 0, u = n && 0 !== n.playbackRate ? Math.abs(n.playbackRate) : 1, d = this.bwEstimator ? this.bwEstimator.getEstimate() : i.abrEwmaDefaultEstimate, f = (v.default.bufferInfo(n, l, i.maxBufferHole).end - l) / u, c = this.findBestLevel(s, o, d, a, t, f, i.abrBandWidthFactor, i.abrBandWidthUpFactor, r);
                if (c >= 0)return c;
                p.logger.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");
                var h = i.maxStarvationDelay, g = i.abrBandWidthFactor, y = i.abrBandWidthUpFactor;
                if (0 === f) {
                    var m = this.bitrateTestDelay;
                    m && (h = i.maxLoadingDelay - m, p.logger.trace("bitrate test took " + Math.round(1e3 * m) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * h) + " ms"), g = y = 1)
                }
                return c = this.findBestLevel(s, o, d, a, t, f + h, g, y, r), Math.max(c, 0)
            }
        }]), t
    }(c.default);
    t.default = E
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(10), d = i(u), f = r(5), c = i(f), h = r(8), v = i(h), g = r(2), p = i(g), y = r(4), m = i(y), E = r(9), b = i(E), k = r(11), R = i(k), _ = r(3), S = r(1), T = {
        STOPPED: "STOPPED",
        STARTING: "STARTING",
        IDLE: "IDLE",
        PAUSED: "PAUSED",
        KEY_LOADING: "KEY_LOADING",
        FRAG_LOADING: "FRAG_LOADING",
        FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
        WAITING_TRACK: "WAITING_TRACK",
        PARSING: "PARSING",
        PARSED: "PARSED",
        ENDED: "ENDED",
        ERROR: "ERROR"
    }, A = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, p.default.MEDIA_ATTACHED, p.default.MEDIA_DETACHING, p.default.AUDIO_TRACKS_UPDATED, p.default.AUDIO_TRACK_SWITCH, p.default.AUDIO_TRACK_LOADED, p.default.KEY_LOADED, p.default.FRAG_LOADED, p.default.FRAG_PARSING_INIT_SEGMENT, p.default.FRAG_PARSING_DATA, p.default.FRAG_PARSED, p.default.ERROR, p.default.BUFFER_CREATED, p.default.BUFFER_APPENDED, p.default.BUFFER_FLUSHED));
            return r.config = e.config, r.audioCodecSwap = !1, r.ticks = 0, r.ontick = r.tick.bind(r), r
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), m.default.prototype.destroy.call(this), this.state = T.STOPPED
            }
        }, {
            key: "startLoad", value: function (e) {
                if (this.tracks) {
                    var t = this.media, r = this.lastCurrentTime;
                    this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.fragLoadError = 0, t && r ? (S.logger.log("configure startPosition @" + r), this.state = T.IDLE) : (this.lastCurrentTime = this.startPosition ? this.startPosition : e, this.state = T.STARTING), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick()
                } else this.startPosition = e, this.state = T.STOPPED
            }
        }, {
            key: "stopLoad", value: function () {
                var e = this.fragCurrent;
                e && (e.loader && e.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = T.STOPPED
            }
        }, {
            key: "tick", value: function () {
                this.ticks++, 1 === this.ticks && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0)
            }
        }, {
            key: "doTick", value: function () {
                var e, t, r, i = this.hls, a = i.config;
                switch (this.state) {
                    case T.ERROR:
                    case T.PAUSED:
                        break;
                    case T.STARTING:
                        this.state = T.WAITING_TRACK, this.loadedmetadata = !1;
                        break;
                    case T.IDLE:
                        if (!this.media && (this.startFragRequested || !a.startFragPrefetch))break;
                        e = this.loadedmetadata ? this.media.currentTime : this.nextLoadPosition;
                        var n = this.mediaBuffer ? this.mediaBuffer : this.media, s = c.default.bufferInfo(n, e, a.maxBufferHole), o = s.len, l = s.end, u = this.fragPrevious, f = a.maxMaxBufferLength;
                        if (o < f && this.trackId < this.tracks.length) {
                            if (r = this.tracks[this.trackId].details, "undefined" == typeof r) {
                                this.state = T.WAITING_TRACK;
                                break
                            }
                            if (!r.live && u && u.sn === r.endSN && (!this.media.seeking || this.media.duration - l < u.duration / 2)) {
                                this.hls.trigger(p.default.BUFFER_EOS, {type: "audio"}), this.state = T.ENDED;
                                break
                            }
                            var h = r.fragments, v = h.length, g = h[0].start, y = h[v - 1].start + h[v - 1].duration, m = void 0;
                            if (l < g ? m = h[0] : !function () {
                                    var e = void 0, t = a.maxFragLookUpTolerance;
                                    l < y ? (l > y - t && (t = 0), e = d.default.search(h, function (e) {
                                        return e.start + e.duration - t <= l ? 1 : e.start - t > l ? -1 : 0
                                    })) : e = h[v - 1], e && (m = e, g = e.start, u && m.level === u.level && m.sn === u.sn && (m.sn < r.endSN ? (m = h[m.sn + 1 - r.startSN], S.logger.log("SN just loaded, load next one: " + m.sn)) : m = null))
                                }(), m)if (null != m.decryptdata.uri && null == m.decryptdata.key)S.logger.log("Loading key for " + m.sn + " of [" + r.startSN + " ," + r.endSN + "],track " + this.trackId), this.state = T.KEY_LOADING, i.trigger(p.default.KEY_LOADING, {frag: m}); else {
                                if (S.logger.log("Loading " + m.sn + " of [" + r.startSN + " ," + r.endSN + "],track " + this.trackId + ", currentTime:" + e + ",bufferEnd:" + l.toFixed(3)), void 0 !== this.fragLoadIdx ? this.fragLoadIdx++ : this.fragLoadIdx = 0, m.loadCounter) {
                                    m.loadCounter++;
                                    var E = a.fragLoadingLoopThreshold;
                                    if (m.loadCounter > E && Math.abs(this.fragLoadIdx - m.loadIdx) < E)return void i.trigger(p.default.ERROR, {
                                        type: _.ErrorTypes.MEDIA_ERROR,
                                        details: _.ErrorDetails.FRAG_LOOP_LOADING_ERROR,
                                        fatal: !1,
                                        frag: m
                                    })
                                } else m.loadCounter = 1;
                                m.loadIdx = this.fragLoadIdx, this.fragCurrent = m, this.startFragRequested = !0, i.trigger(p.default.FRAG_LOADING, {frag: m}), this.state = T.FRAG_LOADING
                            }
                        }
                        break;
                    case T.WAITING_TRACK:
                        t = this.tracks[this.trackId], t && t.details && (this.state = T.IDLE);
                        break;
                    case T.FRAG_LOADING_WAITING_RETRY:
                        var b = performance.now(), k = this.retryDate;
                        n = this.media;
                        var R = n && n.seeking;
                        (!k || b >= k || R) && (S.logger.log("audioStreamController: retryDate reached, switch back to IDLE state"), this.state = T.IDLE);
                        break;
                    case T.STOPPED:
                    case T.FRAG_LOADING:
                    case T.PARSING:
                    case T.PARSED:
                    case T.ENDED:
                }
            }
        }, {
            key: "onMediaAttached", value: function (e) {
                var t = this.media = this.mediaBuffer = e.media;
                this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener("seeking", this.onvseeking), t.addEventListener("ended", this.onvended);
                var r = this.config;
                this.tracks && r.autoStartLoad && this.startLoad(r.startPosition)
            }
        }, {
            key: "onMediaDetaching", value: function () {
                var e = this.media;
                e && e.ended && (S.logger.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
                var t = this.tracks;
                t && t.forEach(function (e) {
                    e.details && e.details.fragments.forEach(function (e) {
                        e.loadCounter = void 0
                    })
                }), e && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = null, this.loadedmetadata = !1, this.stopLoad()
            }
        }, {
            key: "onMediaSeeking", value: function () {
                this.state === T.ENDED && (this.state = T.IDLE), this.media && (this.lastCurrentTime = this.media.currentTime), void 0 !== this.fragLoadIdx && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.tick()
            }
        }, {
            key: "onMediaEnded", value: function () {
                this.startPosition = this.lastCurrentTime = 0
            }
        }, {
            key: "onAudioTracksUpdated", value: function (e) {
                S.logger.log("audio tracks updated"), this.tracks = e.audioTracks
            }
        }, {
            key: "onAudioTrackSwitch", value: function (e) {
                var t = !!e.url;
                this.trackId = e.id, this.state = T.IDLE, this.fragCurrent = null, this.state = T.PAUSED, t ? this.timer || (this.timer = setInterval(this.ontick, 100)) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.hls.trigger(p.default.BUFFER_FLUSHING, {
                    startOffset: 0,
                    endOffset: Number.POSITIVE_INFINITY,
                    type: "audio"
                }), this.tick()
            }
        }, {
            key: "onAudioTrackLoaded", value: function (e) {
                var t = e.details, r = e.id, i = this.tracks[r], a = t.totalduration;
                if (S.logger.log("track " + r + " loaded [" + t.startSN + "," + t.endSN + "],duration:" + a), t.PTSKnown = !1, i.details = t, !this.startFragRequested) {
                    if (this.startPosition === -1) {
                        var n = t.startTimeOffset;
                        isNaN(n) ? this.startPosition = 0 : (S.logger.log("start time offset found in playlist, adjust startPosition to " + n), this.startPosition = n)
                    }
                    this.nextLoadPosition = this.startPosition
                }
                this.state === T.WAITING_TRACK && (this.state = T.IDLE), this.tick()
            }
        }, {
            key: "onKeyLoaded", value: function () {
                this.state === T.KEY_LOADING && (this.state = T.IDLE, this.tick())
            }
        }, {
            key: "onFragLoaded", value: function (e) {
                var t = this.fragCurrent;
                if (this.state === T.FRAG_LOADING && t && "audio" === e.frag.type && e.frag.level === t.level && e.frag.sn === t.sn) {
                    this.state = T.PARSING, this.stats = e.stats;
                    var r = this.tracks[this.trackId], i = r.details, a = i.totalduration, n = t.start, s = t.level, o = t.sn, l = this.config.defaultAudioCodec || r.audioCodec;
                    this.pendingAppending = 0, this.demuxer || (this.demuxer = new v.default(this.hls, "audio")), S.logger.log("Demuxing " + o + " of [" + i.startSN + " ," + i.endSN + "],track " + s);
                    var u = i.PTSKnown || !i.live;
                    this.demuxer.push(e.payload, l, null, n, t.cc, s, o, a, t.decryptdata, u)
                }
                this.fragLoadError = 0
            }
        }, {
            key: "onFragParsingInitSegment", value: function (e) {
                var t = this.fragCurrent;
                if (t && "audio" === e.id && e.sn === t.sn && e.level === t.level && this.state === T.PARSING) {
                    var r = e.tracks, i = void 0;
                    if (i = r.audio) {
                        i.levelCodec = "mp4a.40.2", i.id = e.id, this.hls.trigger(p.default.BUFFER_CODECS, r), S.logger.log("audio track:audio,container:" + i.container + ",codecs[level/parsed]=[" + i.levelCodec + "/" + i.codec + "]");
                        var a = i.initSegment;
                        a && (this.pendingAppending++, this.hls.trigger(p.default.BUFFER_APPENDING, {
                            type: "audio",
                            data: a,
                            parent: "audio",
                            content: "initSegment"
                        })), this.tick()
                    }
                }
            }
        }, {
            key: "onFragParsingData", value: function (e) {
                var t = this, r = this.fragCurrent;
                if (r && "audio" === e.id && e.sn === r.sn && e.level === r.level && this.state === T.PARSING) {
                    var i = this.tracks[this.trackId], a = this.fragCurrent;
                    S.logger.log("parsed " + e.type + ",PTS:[" + e.startPTS.toFixed(3) + "," + e.endPTS.toFixed(3) + "],DTS:[" + e.startDTS.toFixed(3) + "/" + e.endDTS.toFixed(3) + "],nb:" + e.nb), b.default.updateFragPTSDTS(i.details, a.sn, e.startPTS, e.endPTS), [e.data1, e.data2].forEach(function (r) {
                        r && (t.pendingAppending++, t.hls.trigger(p.default.BUFFER_APPENDING, {
                            type: e.type,
                            data: r,
                            parent: "audio",
                            content: "data"
                        }))
                    }), this.nextLoadPosition = e.endPTS, this.tick()
                }
            }
        }, {
            key: "onFragParsed", value: function (e) {
                var t = this.fragCurrent;
                t && "audio" === e.id && e.sn === t.sn && e.level === t.level && this.state === T.PARSING && (this.stats.tparsed = performance.now(), this.state = T.PARSED, this._checkAppendedParsed())
            }
        }, {
            key: "onBufferCreated", value: function (e) {
                var t = e.tracks.audio;
                t && (this.mediaBuffer = t.buffer, this.loadedmetadata = !0)
            }
        }, {
            key: "onBufferAppended", value: function (e) {
                if ("audio" === e.parent)switch (this.state) {
                    case T.PARSING:
                    case T.PARSED:
                        this.pendingAppending--, this._checkAppendedParsed()
                }
            }
        }, {
            key: "_checkAppendedParsed", value: function () {
                if (this.state === T.PARSED && 0 === this.pendingAppending) {
                    var e = this.fragCurrent, t = this.stats;
                    if (e) {
                        this.fragPrevious = e, t.tbuffered = performance.now(), this.hls.trigger(p.default.FRAG_BUFFERED, {
                            stats: t,
                            frag: e,
                            id: "audio"
                        });
                        var r = this.mediaBuffer ? this.mediaBuffer : this.media;
                        S.logger.log("audio buffered : " + R.default.toString(r.buffered)), this.state = T.IDLE
                    }
                    this.tick()
                }
            }
        }, {
            key: "onError", value: function (e) {
                var t = e.frag;
                if (!t || "audio" === t.type)switch (e.details) {
                    case _.ErrorDetails.FRAG_LOAD_ERROR:
                    case _.ErrorDetails.FRAG_LOAD_TIMEOUT:
                        if (!e.fatal) {
                            var r = this.fragLoadError;
                            r ? r++ : r = 1;
                            var i = this.config;
                            if (r <= i.fragLoadingMaxRetry) {
                                this.fragLoadError = r, t.loadCounter = 0;
                                var a = Math.min(Math.pow(2, r - 1) * i.fragLoadingRetryDelay, i.fragLoadingMaxRetryTimeout);
                                S.logger.warn("audioStreamController: frag loading failed, retry in " + a + " ms"), this.retryDate = performance.now() + a, this.state = T.FRAG_LOADING_WAITING_RETRY
                            } else S.logger.error("audioStreamController: " + e.details + " reaches max retry, redispatch as fatal ..."), e.fatal = !0, this.hls.trigger(p.default.ERROR, e), this.state = T.ERROR
                        }
                        break;
                    case _.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
                    case _.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
                    case _.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
                    case _.ErrorDetails.KEY_LOAD_ERROR:
                    case _.ErrorDetails.KEY_LOAD_TIMEOUT:
                        this.state !== T.ERROR && (this.state = e.fatal ? T.ERROR : T.IDLE, S.logger.warn("audioStreamController: " + e.details + " while loading frag,switch to " + this.state + " state ..."))
                }
            }
        }, {
            key: "onBufferFlushed", value: function () {
                this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold, this.state = T.IDLE, this.fragPrevious = null, this.tick()
            }
        }]), t
    }(m.default);
    t.default = A
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = r(1), v = function (e) {
        function t(e) {
            return a(this, t), n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.MANIFEST_LOADING, d.default.MANIFEST_LOADED, d.default.AUDIO_TRACK_LOADED))
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                c.default.prototype.destroy.call(this)
            }
        }, {
            key: "onManifestLoading", value: function () {
                this.tracks = [], this.trackId = -1
            }
        }, {
            key: "onManifestLoaded", value: function (e) {
                var t = this, r = e.audioTracks || [], i = !1;
                this.tracks = r, this.hls.trigger(d.default.AUDIO_TRACKS_UPDATED, {audioTracks: r});
                var a = 0;
                r.forEach(function (e) {
                    return e.default ? (t.audioTrack = a, void(i = !0)) : void a++
                }), i === !1 && r.length && (h.logger.log("no default audio track defined, use first audio track as default"), this.audioTrack = 0)
            }
        }, {
            key: "onAudioTrackLoaded", value: function (e) {
                e.id < this.tracks.length && (h.logger.log("audioTrack " + e.id + " loaded"), this.tracks[e.id].details = e.details, e.details.live && !this.timer && (this.timer = setInterval(this.ontick, 1e3 * e.details.targetduration)), !e.details.live && this.timer && (clearInterval(this.timer), this.timer = null))
            }
        }, {
            key: "setAudioTrackInternal", value: function (e) {
                if (e >= 0 && e < this.tracks.length) {
                    this.timer && (clearInterval(this.timer), this.timer = null), this.trackId = e, h.logger.log("switching to audioTrack " + e);
                    var t = this.tracks[e], r = t.type, i = t.url;
                    this.hls.trigger(d.default.AUDIO_TRACK_SWITCH, {id: e, type: r, url: i});
                    var a = t.details;
                    !i || void 0 !== a && a.live !== !0 || (h.logger.log("(re)loading playlist for audioTrack " + e), this.hls.trigger(d.default.AUDIO_TRACK_LOADING, {
                        url: i,
                        id: e
                    }))
                }
            }
        }, {
            key: "audioTracks", get: function () {
                return this.tracks
            }
        }, {
            key: "audioTrack", get: function () {
                return this.trackId
            }, set: function (e) {
                this.trackId === e && void 0 !== this.tracks[e].details || this.setAudioTrackInternal(e)
            }
        }]), t
    }(c.default);
    t.default = v
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = r(1), v = r(3), g = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.MEDIA_ATTACHING, d.default.MEDIA_DETACHING, d.default.MANIFEST_PARSED, d.default.BUFFER_RESET, d.default.BUFFER_APPENDING, d.default.BUFFER_CODECS, d.default.BUFFER_EOS, d.default.BUFFER_FLUSHING, d.default.LEVEL_UPDATED));
            return r._msDuration = null, r._levelDuration = null, r.onsbue = r.onSBUpdateEnd.bind(r), r.onsbe = r.onSBUpdateError.bind(r), r.pendingTracks = {}, r
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                c.default.prototype.destroy.call(this)
            }
        }, {
            key: "onManifestParsed", value: function (e) {
                var t = e.audio, r = e.video, i = 0;
                e.altAudio && (t || r) && (i = (t ? 1 : 0) + (r ? 1 : 0), h.logger.log(i + " sourceBuffer(s) expected")), this.sourceBufferNb = i
            }
        }, {
            key: "onMediaAttaching", value: function (e) {
                var t = this.media = e.media;
                if (t) {
                    var r = this.mediaSource = new MediaSource;
                    this.onmso = this.onMediaSourceOpen.bind(this), this.onmse = this.onMediaSourceEnded.bind(this), this.onmsc = this.onMediaSourceClose.bind(this), r.addEventListener("sourceopen", this.onmso), r.addEventListener("sourceended", this.onmse), r.addEventListener("sourceclose", this.onmsc), t.src = URL.createObjectURL(r)
                }
            }
        }, {
            key: "onMediaDetaching", value: function () {
                h.logger.log("media source detaching");
                var e = this.mediaSource;
                if (e) {
                    if ("open" === e.readyState)try {
                        e.endOfStream()
                    } catch (e) {
                        h.logger.warn("onMediaDetaching:" + e.message + " while calling endOfStream")
                    }
                    e.removeEventListener("sourceopen", this.onmso), e.removeEventListener("sourceended", this.onmse), e.removeEventListener("sourceclose", this.onmsc), this.media && (this.media.removeAttribute("src"), this.media.load()), this.mediaSource = null, this.media = null, this.pendingTracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0
                }
                this.onmso = this.onmse = this.onmsc = null, this.hls.trigger(d.default.MEDIA_DETACHED)
            }
        }, {
            key: "onMediaSourceOpen", value: function () {
                h.logger.log("media source opened"), this.hls.trigger(d.default.MEDIA_ATTACHED, {media: this.media});
                var e = this.mediaSource;
                e && e.removeEventListener("sourceopen", this.onmso), this.checkPendingTracks()
            }
        }, {
            key: "checkPendingTracks", value: function () {
                var e = this.pendingTracks, t = Object.keys(e).length;
                t && (this.sourceBufferNb <= t || 0 === this.sourceBufferNb) && (this.createSourceBuffers(e), this.pendingTracks = {}, this.doAppending())
            }
        }, {
            key: "onMediaSourceClose", value: function () {
                h.logger.log("media source closed")
            }
        }, {
            key: "onMediaSourceEnded", value: function () {
                h.logger.log("media source ended")
            }
        }, {
            key: "onSBUpdateEnd", value: function () {
                this._needsFlush && this.doFlush(), this._needsEos && this.checkEos(), this.appending = !1, this.hls.trigger(d.default.BUFFER_APPENDED, {parent: this.parent}), this._needsFlush || this.doAppending(), this.updateMediaElementDuration()
            }
        }, {
            key: "onSBUpdateError", value: function (e) {
                h.logger.error("sourceBuffer error:" + e), this.hls.trigger(d.default.ERROR, {
                    type: v.ErrorTypes.MEDIA_ERROR,
                    details: v.ErrorDetails.BUFFER_APPENDING_ERROR,
                    fatal: !1
                })
            }
        }, {
            key: "onBufferReset", value: function () {
                var e = this.sourceBuffer;
                for (var t in e) {
                    var r = e[t];
                    try {
                        this.mediaSource.removeSourceBuffer(r), r.removeEventListener("updateend", this.onsbue), r.removeEventListener("error", this.onsbe)
                    } catch (e) {
                    }
                }
                this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0
            }
        }, {
            key: "onBufferCodecs", value: function (e) {
                if (0 === Object.keys(this.sourceBuffer).length) {
                    for (var t in e)this.pendingTracks[t] = e[t];
                    var r = this.mediaSource;
                    r && "open" === r.readyState && this.checkPendingTracks()
                }
            }
        }, {
            key: "createSourceBuffers", value: function (e) {
                var t = this.sourceBuffer, r = this.mediaSource;
                for (var i in e)if (!t[i]) {
                    var a = e[i], n = a.levelCodec || a.codec, s = a.container + ";codecs=" + n;
                    h.logger.log("creating sourceBuffer(" + s + ")");
                    try {
                        var o = t[i] = r.addSourceBuffer(s);
                        o.addEventListener("updateend", this.onsbue), o.addEventListener("error", this.onsbe), a.buffer = o
                    } catch (e) {
                        h.logger.error("error while trying to add sourceBuffer:" + e.message), this.hls.trigger(d.default.ERROR, {
                            type: v.ErrorTypes.MEDIA_ERROR,
                            details: v.ErrorDetails.BUFFER_ADD_CODEC_ERROR,
                            fatal: !1,
                            err: e,
                            mimeType: s
                        })
                    }
                }
                this.hls.trigger(d.default.BUFFER_CREATED, {tracks: e})
            }
        }, {
            key: "onBufferAppending", value: function (e) {
                this._needsFlush || (this.segments ? this.segments.push(e) : this.segments = [e], this.doAppending())
            }
        }, {
            key: "onBufferAppendFail", value: function (e) {
                h.logger.error("sourceBuffer error:" + e.event), this.hls.trigger(d.default.ERROR, {
                    type: v.ErrorTypes.MEDIA_ERROR,
                    details: v.ErrorDetails.BUFFER_APPENDING_ERROR,
                    fatal: !1,
                    frag: this.fragCurrent
                })
            }
        }, {
            key: "onBufferEos", value: function (e) {
                var t = this.sourceBuffer, r = e.type;
                for (var i in t)r && i !== r || t[i].ended || (t[i].ended = !0, h.logger.log(i + " sourceBuffer now EOS"));
                this.checkEos()
            }
        }, {
            key: "checkEos", value: function () {
                var e = this.sourceBuffer, t = this.mediaSource;
                if (!t || "open" !== t.readyState)return void(this._needsEos = !1);
                for (var r in e) {
                    if (!e[r].ended)return;
                    if (e[r].updating)return void(this._needsEos = !0)
                }
                h.logger.log("all media data available, signal endOfStream() to MediaSource and stop loading fragment"), t.endOfStream(), this._needsEos = !1
            }
        }, {
            key: "onBufferFlushing", value: function (e) {
                this.flushRange.push({
                    start: e.startOffset,
                    end: e.endOffset,
                    type: e.type
                }), this.flushBufferCounter = 0, this.doFlush()
            }
        }, {
            key: "onLevelUpdated", value: function (e) {
                var t = e.details;
                0 !== t.fragments.length && (this._levelDuration = t.totalduration + t.fragments[0].start, this.updateMediaElementDuration())
            }
        }, {
            key: "updateMediaElementDuration", value: function () {
                var e = this.media, t = this.mediaSource, r = this.sourceBuffer, i = this._levelDuration;
                if (null !== i && e && t && r && 0 !== e.readyState && "open" === t.readyState) {
                    for (var a in r)if (r[a].updating)return;
                    null === this._msDuration && (this._msDuration = t.duration), i > this._msDuration && i > e.duration && (h.logger.log("Updating mediasource duration to " + i.toFixed(3)), this._msDuration = t.duration = i)
                }
            }
        }, {
            key: "doFlush", value: function () {
                for (; this.flushRange.length;) {
                    var e = this.flushRange[0];
                    if (!this.flushBuffer(e.start, e.end, e.type))return void(this._needsFlush = !0);
                    this.flushRange.shift(), this.flushBufferCounter = 0
                }
                if (0 === this.flushRange.length) {
                    this._needsFlush = !1;
                    var t = 0, r = this.sourceBuffer;
                    for (var i in r)t += r[i].buffered.length;
                    this.appended = t, this.hls.trigger(d.default.BUFFER_FLUSHED)
                }
            }
        }, {
            key: "doAppending", value: function () {
                var e = this.hls, t = this.sourceBuffer, r = this.segments;
                if (Object.keys(t).length) {
                    if (this.media.error)return this.segments = [], void h.logger.error("trying to append although a media error occured, flush segment and abort");
                    if (this.appending)return;
                    if (r && r.length) {
                        var i = r.shift();
                        try {
                            var a = i.type;
                            t[a] ? (t[a].ended = !1, this.parent = i.parent, t[a].appendBuffer(i.data), this.appendError = 0, this.appended++, this.appending = !0) : this.onSBUpdateEnd()
                        } catch (t) {
                            h.logger.error("error while trying to append buffer:" + t.message), r.unshift(i);
                            var n = {type: v.ErrorTypes.MEDIA_ERROR};
                            if (22 === t.code)return this.segments = [], n.details = v.ErrorDetails.BUFFER_FULL_ERROR, void e.trigger(d.default.ERROR, n);
                            if (this.appendError ? this.appendError++ : this.appendError = 1, n.details = v.ErrorDetails.BUFFER_APPEND_ERROR, n.frag = this.fragCurrent, this.appendError > e.config.appendErrorMaxRetry)return h.logger.log("fail " + e.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), r = [], n.fatal = !0, void e.trigger(d.default.ERROR, n);
                            n.fatal = !1, e.trigger(d.default.ERROR, n)
                        }
                    }
                }
            }
        }, {
            key: "flushBuffer", value: function (e, t, r) {
                var i, a, n, s, o, l, u = this.sourceBuffer;
                if (Object.keys(u).length) {
                    if (h.logger.log("flushBuffer,pos/start/end: " + this.media.currentTime + "/" + e + "/" + t), this.flushBufferCounter < this.appended) {
                        for (var d in u)if (!r || d === r) {
                            if (i = u[d], i.ended = !1, i.updating)return h.logger.warn("cannot flush, sb updating in progress"), !1;
                            for (a = 0; a < i.buffered.length; a++)if (n = i.buffered.start(a), s = i.buffered.end(a), navigator.userAgent.toLowerCase().indexOf("firefox") !== -1 && t === Number.POSITIVE_INFINITY ? (o = e, l = t) : (o = Math.max(n, e), l = Math.min(s, t)), Math.min(l, s) - o > .5)return this.flushBufferCounter++, h.logger.log("flush " + d + " [" + o + "," + l + "], of [" + n + "," + s + "], pos:" + this.media.currentTime), i.remove(o, l), !1
                        }
                    } else h.logger.warn("abort flushing too many retries");
                    h.logger.log("buffer flushed")
                }
                return !0
            }
        }]), t
    }(c.default);
    t.default = g
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = function (e) {
        function t(e) {
            return a(this, t), n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.FPS_DROP_LEVEL_CAPPING, d.default.MEDIA_ATTACHING, d.default.MANIFEST_PARSED))
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                this.hls.config.capLevelToPlayerSize && (this.media = this.restrictedLevels = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer)))
            }
        }, {
            key: "onFpsDropLevelCapping", value: function (e) {
                this.restrictedLevels || (this.restrictedLevels = []), this.isLevelRestricted(e.droppedLevel) || this.restrictedLevels.push(e.droppedLevel)
            }
        }, {
            key: "onMediaAttaching", value: function (e) {
                this.media = e.media instanceof HTMLVideoElement ? e.media : null
            }
        }, {
            key: "onManifestParsed", value: function (e) {
                this.hls.config.capLevelToPlayerSize && (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.levels = e.levels, this.hls.firstLevel = this.getMaxLevel(e.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
            }
        }, {
            key: "detectPlayerSize", value: function () {
                if (this.media) {
                    var e = this.levels ? this.levels.length : 0;
                    e && (this.hls.autoLevelCapping = this.getMaxLevel(e - 1), this.hls.autoLevelCapping > this.autoLevelCapping && this.hls.streamController.nextLevelSwitch(), this.autoLevelCapping = this.hls.autoLevelCapping)
                }
            }
        }, {
            key: "getMaxLevel", value: function (e) {
                var t = 0, r = void 0, i = void 0, a = this.mediaWidth, n = this.mediaHeight, s = 0, o = 0;
                for (r = 0; r <= e && (i = this.levels[r], !this.isLevelRestricted(r)) && (t = r, s = i.width, o = i.height, !(a <= s || n <= o)); r++);
                return t
            }
        }, {
            key: "isLevelRestricted", value: function (e) {
                return !(!this.restrictedLevels || this.restrictedLevels.indexOf(e) === -1)
            }
        }, {
            key: "contentScaleFactor", get: function () {
                var e = 1;
                try {
                    e = window.devicePixelRatio
                } catch (e) {
                }
                return e
            }
        }, {
            key: "mediaWidth", get: function () {
                var e = void 0;
                return this.media && (e = this.media.width || this.media.clientWidth || this.media.offsetWidth, e *= this.contentScaleFactor), e
            }
        }, {
            key: "mediaHeight", get: function () {
                var e = void 0;
                return this.media && (e = this.media.height || this.media.clientHeight || this.media.offsetHeight, e *= this.contentScaleFactor), e
            }
        }]), t
    }(c.default);
    t.default = h
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(45), o = i(s), l = function () {
        function e(t, r, i, n) {
            a(this, e), this.hls = t, this.defaultEstimate_ = n, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new o.default(r), this.fast_ = new o.default(i)
        }

        return n(e, [{
            key: "sample", value: function (e, t) {
                e = Math.max(e, this.minDelayMs_);
                var r = 8e3 * t / e, i = e / 1e3;
                this.fast_.sample(i, r), this.slow_.sample(i, r)
            }
        }, {
            key: "canEstimate", value: function () {
                var e = this.fast_;
                return e && e.getTotalWeight() >= this.minWeight_
            }
        }, {
            key: "getEstimate", value: function () {
                return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
            }
        }, {
            key: "destroy", value: function () {
            }
        }]), e
    }();
    t.default = l
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = r(1), v = function (e) {
        function t(e) {
            return a(this, t), n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.MEDIA_ATTACHING))
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1
            }
        }, {
            key: "onMediaAttaching", value: function (e) {
                this.hls.config.capLevelOnFPSDrop && (this.video = e.media instanceof HTMLVideoElement ? e.media : null, "function" == typeof this.video.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), this.hls.config.fpsDroppedMonitoringPeriod))
            }
        }, {
            key: "checkFPS", value: function (e, t, r) {
                var i = performance.now();
                if (t) {
                    if (this.lastTime) {
                        var a = i - this.lastTime, n = r - this.lastDroppedFrames, s = t - this.lastDecodedFrames, o = 1e3 * n / a;
                        if (this.hls.trigger(d.default.FPS_DROP, {
                                currentDropped: n,
                                currentDecoded: s,
                                totalDroppedFrames: r
                            }), o > 0 && n > this.hls.config.fpsDroppedMonitoringThreshold * s) {
                            var l = this.hls.currentLevel;
                            h.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + l), l > 0 && (this.hls.autoLevelCapping === -1 || this.hls.autoLevelCapping >= l) && (l -= 1, this.hls.trigger(d.default.FPS_DROP_LEVEL_CAPPING, {
                                level: l,
                                droppedLevel: this.hls.currentLevel
                            }), this.hls.autoLevelCapping = l, this.hls.streamController.nextLevelSwitch())
                        }
                    }
                    this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = t
                }
            }
        }, {
            key: "checkFPSInterval", value: function () {
                if (this.video)if (this.isVideoPlaybackQualityAvailable) {
                    var e = this.video.getVideoPlaybackQuality();
                    this.checkFPS(this.video, e.totalVideoFrames, e.droppedVideoFrames)
                } else this.checkFPS(this.video, this.video.webkitDecodedFrameCount, this.video.webkitDroppedFrameCount)
            }
        }]), t
    }(c.default);
    t.default = v
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = r(1), v = r(3), g = r(5), p = i(g), y = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.MANIFEST_LOADED, d.default.LEVEL_LOADED, d.default.ERROR));
            return r.ontick = r.tick.bind(r), r._manualLevel = r._autoLevelCapping = -1, r
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                this.timer && (clearTimeout(this.timer), this.timer = null), this._manualLevel = -1
            }
        }, {
            key: "startLoad", value: function () {
                this.canload = !0, this.timer && this.tick()
            }
        }, {
            key: "stopLoad", value: function () {
                this.canload = !1
            }
        }, {
            key: "onManifestLoaded", value: function (e) {
                var t, r, i = [], a = [], n = {}, s = !1, o = !1, l = this.hls;
                if (e.levels.forEach(function (e) {
                        e.videoCodec && (s = !0), (e.audioCodec || e.attrs && e.attrs.AUDIO) && (o = !0);
                        var t = n[e.bitrate];
                        void 0 === t ? (n[e.bitrate] = i.length, e.url = [e.url], e.urlId = 0, i.push(e)) : i[t].url.push(e.url)
                    }), s && o ? i.forEach(function (e) {
                        e.videoCodec && a.push(e)
                    }) : a = i, a = a.filter(function (e) {
                        var t = function (e) {
                            return MediaSource.isTypeSupported("audio/mp4;codecs=" + e)
                        }, r = function (e) {
                            return MediaSource.isTypeSupported("video/mp4;codecs=" + e)
                        }, i = e.audioCodec, a = e.videoCodec;
                        return (!i || t(i)) && (!a || r(a))
                    }), a.length) {
                    for (t = a[0].bitrate, a.sort(function (e, t) {
                        return e.bitrate - t.bitrate
                    }), this._levels = a, r = 0; r < a.length; r++)if (a[r].bitrate === t) {
                        this._firstLevel = r, h.logger.log("manifest loaded," + a.length + " level(s) found, first bitrate:" + t);
                        break
                    }
                    l.trigger(d.default.MANIFEST_PARSED, {
                        levels: this._levels,
                        firstLevel: this._firstLevel,
                        stats: e.stats,
                        audio: o,
                        video: s,
                        altAudio: e.audioTracks.length > 0
                    })
                } else l.trigger(d.default.ERROR, {
                    type: v.ErrorTypes.MEDIA_ERROR,
                    details: v.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                    fatal: !0,
                    url: l.url,
                    reason: "no level with compatible codecs found in manifest"
                })
            }
        }, {
            key: "setLevelInternal", value: function (e) {
                var t = this._levels;
                if (e >= 0 && e < t.length) {
                    this.timer && (clearTimeout(this.timer), this.timer = null), this._level !== e && (h.logger.log("switching to level " + e), this._level = e), this.hls.trigger(d.default.LEVEL_SWITCH, {level: e});
                    var r = t[e], i = r.details;
                    if (!i || i.live === !0) {
                        var a = r.urlId;
                        this.hls.trigger(d.default.LEVEL_LOADING, {url: r.url[a], level: e, id: a})
                    }
                } else this.hls.trigger(d.default.ERROR, {
                    type: v.ErrorTypes.OTHER_ERROR,
                    details: v.ErrorDetails.LEVEL_SWITCH_ERROR,
                    level: e,
                    fatal: !1,
                    reason: "invalid level idx"
                })
            }
        }, {
            key: "onError", value: function (e) {
                if (!e.fatal) {
                    var t = e.details, r = this.hls, i = void 0, a = void 0, n = !1;
                    switch (t) {
                        case v.ErrorDetails.FRAG_LOAD_ERROR:
                        case v.ErrorDetails.FRAG_LOAD_TIMEOUT:
                        case v.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
                        case v.ErrorDetails.KEY_LOAD_ERROR:
                        case v.ErrorDetails.KEY_LOAD_TIMEOUT:
                            i = e.frag.level;
                            break;
                        case v.ErrorDetails.LEVEL_LOAD_ERROR:
                        case v.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                            i = e.context.level, n = !0
                    }
                    if (void 0 !== i)if (a = this._levels[i], a.urlId < a.url.length - 1)a.urlId++, a.details = void 0, h.logger.warn("level controller," + t + " for level " + i + ": switching to redundant stream id " + a.urlId); else {
                        var s = this._manualLevel === -1 && i;
                        if (s)h.logger.warn("level controller," + t + ": emergency switch-down for next fragment"), r.abrController.nextAutoLevel = 0; else if (a && a.details && a.details.live)h.logger.warn("level controller," + t + " on live stream, discard"), n && (this._level = void 0); else if (t === v.ErrorDetails.LEVEL_LOAD_ERROR || t === v.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
                            var o = this.hls, l = o.media, u = l && p.default.isBuffered(l, l.currentTime) && p.default.isBuffered(l, l.currentTime + .5);
                            if (u) {
                                var f = o.config.levelLoadingRetryDelay;
                                h.logger.warn("level controller," + t + ", but media buffered, retry in " + f + "ms"), this.timer = setTimeout(this.ontick, f)
                            } else h.logger.error("cannot recover " + t + " error"), this._level = void 0, this.timer && (clearTimeout(this.timer), this.timer = null), e.fatal = !0, o.trigger(d.default.ERROR, e)
                        }
                    }
                }
            }
        }, {
            key: "onLevelLoaded", value: function (e) {
                if (e.level === this._level) {
                    var t = e.details;
                    if (t.live) {
                        var r = 1e3 * (t.averagetargetduration ? t.averagetargetduration : t.targetduration), i = this._levels[e.level], a = i.details;
                        a && t.endSN === a.endSN && (r /= 2, h.logger.log("same live playlist, reload twice faster")), r -= performance.now() - e.stats.trequest, r = Math.max(1e3, Math.round(r)), h.logger.log("live playlist, reload in " + r + " ms"), this.timer = setTimeout(this.ontick, r)
                    } else this.timer = null
                }
            }
        }, {
            key: "tick", value: function () {
                var e = this._level;
                if (void 0 !== e && this.canload) {
                    var t = this._levels[e], r = t.urlId;
                    this.hls.trigger(d.default.LEVEL_LOADING, {url: t.url[r], level: e, id: r})
                }
            }
        }, {
            key: "levels", get: function () {
                return this._levels
            }
        }, {
            key: "level", get: function () {
                return this._level
            }, set: function (e) {
                var t = this._levels;
                t && t.length > e && (this._level === e && void 0 !== t[e].details || this.setLevelInternal(e))
            }
        }, {
            key: "manualLevel", get: function () {
                return this._manualLevel
            }, set: function (e) {
                this._manualLevel = e, void 0 === this._startLevel && (this._startLevel = e), e !== -1 && (this.level = e)
            }
        }, {
            key: "firstLevel", get: function () {
                return this._firstLevel
            }, set: function (e) {
                this._firstLevel = e
            }
        }, {
            key: "startLevel", get: function () {
                if (void 0 === this._startLevel) {
                    var e = this.hls.config.startLevel;
                    return void 0 !== e ? e : this._firstLevel
                }
                return this._startLevel
            }, set: function (e) {
                this._startLevel = e
            }
        }, {
            key: "nextLoadLevel", get: function () {
                return this._manualLevel !== -1 ? this._manualLevel : this.hls.abrController.nextAutoLevel
            }, set: function (e) {
                this.level = e, this._manualLevel === -1 && (this.hls.abrController.nextAutoLevel = e)
            }
        }]), t
    }(c.default);
    t.default = y
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(10), d = i(u), f = r(5), c = i(f), h = r(8), v = i(h), g = r(2), p = i(g), y = r(4), m = i(y), E = r(9), b = i(E), k = r(11), R = i(k), _ = r(3), S = r(1), T = {
        STOPPED: "STOPPED",
        IDLE: "IDLE",
        KEY_LOADING: "KEY_LOADING",
        FRAG_LOADING: "FRAG_LOADING",
        FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
        WAITING_LEVEL: "WAITING_LEVEL",
        PARSING: "PARSING",
        PARSED: "PARSED",
        BUFFER_FLUSHING: "BUFFER_FLUSHING",
        ENDED: "ENDED",
        ERROR: "ERROR"
    }, A = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, p.default.MEDIA_ATTACHED, p.default.MEDIA_DETACHING, p.default.MANIFEST_LOADING, p.default.MANIFEST_PARSED, p.default.LEVEL_LOADED, p.default.KEY_LOADED, p.default.FRAG_LOADED, p.default.FRAG_LOAD_EMERGENCY_ABORTED, p.default.FRAG_PARSING_INIT_SEGMENT, p.default.FRAG_PARSING_DATA, p.default.FRAG_PARSED, p.default.ERROR, p.default.AUDIO_TRACK_SWITCH, p.default.BUFFER_CREATED, p.default.BUFFER_APPENDED, p.default.BUFFER_FLUSHED));
            return r.config = e.config, r.audioCodecSwap = !1, r.ticks = 0, r.ontick = r.tick.bind(r), r
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), m.default.prototype.destroy.call(this), this.state = T.STOPPED
            }
        }, {
            key: "startLoad", value: function (e) {
                if (this.levels) {
                    var t = this.media, r = this.lastCurrentTime, i = this.hls;
                    if (this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.level = -1, this.fragLoadError = 0, t && r > 0 ? (S.logger.log("configure startPosition @" + r.toFixed(3)), this.lastPaused || (S.logger.log("resuming video"), t.play())) : this.lastCurrentTime = this.startPosition ? this.startPosition : e, !this.startFragRequested) {
                        var a = i.startLevel;
                        a === -1 && (a = 0, this.bitrateTest = !0), this.level = i.nextLoadLevel = a, this.loadedmetadata = !1
                    }
                    this.state = T.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick()
                } else S.logger.warn("cannot start loading as manifest not parsed yet"), this.state = T.STOPPED
            }
        }, {
            key: "stopLoad", value: function () {
                var e = this.fragCurrent;
                e && (e.loader && e.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = T.STOPPED
            }
        }, {
            key: "tick", value: function () {
                this.ticks++, 1 === this.ticks && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0)
            }
        }, {
            key: "doTick", value: function () {
                switch (this.state) {
                    case T.ERROR:
                        break;
                    case T.BUFFER_FLUSHING:
                        this.fragLoadError = 0;
                        break;
                    case T.IDLE:
                        if (!this._doTickIdle())return;
                        break;
                    case T.WAITING_LEVEL:
                        var e = this.levels[this.level];
                        e && e.details && (this.state = T.IDLE);
                        break;
                    case T.FRAG_LOADING_WAITING_RETRY:
                        var t = performance.now(), r = this.retryDate;
                        (!r || t >= r || this.media && this.media.seeking) && (S.logger.log("mediaController: retryDate reached, switch back to IDLE state"), this.state = T.IDLE);
                        break;
                    case T.ERROR:
                    case T.PAUSED:
                    case T.STOPPED:
                    case T.FRAG_LOADING:
                    case T.PARSING:
                    case T.PARSED:
                    case T.ENDED:
                }
                this._checkBuffer(), this._checkFragmentChanged()
            }
        }, {
            key: "_doTickIdle", value: function () {
                var e = this.hls, t = e.config, r = this.media;
                if (void 0 !== this.levelLastLoaded && !r && (this.startFragRequested || !t.startFragPrefetch))return !0;
                var i = void 0;
                i = this.loadedmetadata ? r.currentTime : this.nextLoadPosition;
                var a = e.nextLoadLevel, n = this.levels[a], s = n.bitrate, o = void 0;
                o = s ? Math.max(8 * t.maxBufferSize / s, t.maxBufferLength) : t.maxBufferLength, o = Math.min(o, t.maxMaxBufferLength);
                var l = c.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : r, i, t.maxBufferHole), u = l.len;
                if (u >= o)return !0;
                S.logger.trace("buffer length of " + u.toFixed(3) + " is below max of " + o.toFixed(3) + ". checking for more payload ..."), this.level = e.nextLoadLevel = a;
                var d = n.details;
                if ("undefined" == typeof d || d.live && this.levelLastLoaded !== a)return this.state = T.WAITING_LEVEL, !0;
                var f = this.fragPrevious;
                if (!d.live && f && f.sn === d.endSN && (!r.seeking && l.len || r.duration - l.end <= f.duration / 2)) {
                    var h = {};
                    return this.altAudio && (h.type = "video"), this.hls.trigger(p.default.BUFFER_EOS, h), this.state = T.ENDED, !0
                }
                return this._fetchPayloadOrEos({pos: i, bufferInfo: l, levelDetails: d})
            }
        }, {
            key: "_fetchPayloadOrEos", value: function (e) {
                var t = e.pos, r = e.bufferInfo, i = e.levelDetails, a = this.fragPrevious, n = this.level, s = i.fragments, o = s.length;
                if (0 === o)return !1;
                var l = s[0].start, u = s[o - 1].start + s[o - 1].duration, d = r.end, f = void 0;
                if (i.live) {
                    var c = this.config.initialLiveManifestSize;
                    if (o < c)return S.logger.warn("Can not start playback of a level, reason: not enough fragments " + o + " < " + c), !1;
                    if (f = this._ensureFragmentAtLivePoint({
                            levelDetails: i,
                            bufferEnd: d,
                            start: l,
                            end: u,
                            fragPrevious: a,
                            fragments: s,
                            fragLen: o
                        }), null === f)return !1
                } else d < l && (f = s[0]);
                return f || (f = this._findFragment({
                    start: l,
                    fragPrevious: a,
                    fragLen: o,
                    fragments: s,
                    bufferEnd: d,
                    end: u,
                    levelDetails: i
                })), !f || this._loadFragmentOrKey({frag: f, level: n, levelDetails: i, pos: t, bufferEnd: d})
            }
        }, {
            key: "_ensureFragmentAtLivePoint", value: function (e) {
                var t = e.levelDetails, r = e.bufferEnd, i = e.start, a = e.end, n = e.fragPrevious, s = e.fragments, o = e.fragLen, l = this.hls.config, u = this.media, d = void 0, f = void 0 !== l.liveMaxLatencyDuration ? l.liveMaxLatencyDuration : l.liveMaxLatencyDurationCount * t.targetduration;
                if (r < Math.max(i, a - f)) {
                    var c = this.liveSyncPosition = this.computeLivePosition(i, t);
                    S.logger.log("buffer end: " + r.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + c.toFixed(3)), r = c, u && u.readyState && u.duration > c && (u.currentTime = c)
                }
                if (t.PTSKnown && r > a && u && u.readyState)return null;
                if (this.startFragRequested && !t.PTSKnown) {
                    if (n) {
                        var h = n.sn + 1;
                        h >= t.startSN && h <= t.endSN && (d = s[h - t.startSN], S.logger.log("live playlist, switching playlist, load frag with next SN: " + d.sn))
                    }
                    d || (d = s[Math.min(o - 1, Math.round(o / 2))], S.logger.log("live playlist, switching playlist, unknown, load middle frag : " + d.sn))
                }
                return d
            }
        }, {
            key: "_findFragment", value: function (e) {
                var t = e.start, r = e.fragPrevious, i = e.fragLen, a = e.fragments, n = e.bufferEnd, s = e.end, o = e.levelDetails, l = this.hls.config, u = void 0, f = void 0, c = l.maxFragLookUpTolerance;
                if (n < s ? (n > s - c && (c = 0), f = d.default.search(a, function (e) {
                        return e.start + e.duration - c <= n ? 1 : e.start - c > n && e.start ? -1 : 0
                    })) : f = a[i - 1], f && (u = f, t = f.start, r && u.level === r.level && u.sn === r.sn))if (u.sn < o.endSN) {
                    var h = r.deltaPTS, v = u.sn - o.startSN;
                    h && h > l.maxBufferHole && r.dropped && v ? (u = a[v - 1], S.logger.warn("SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this"), r.loadCounter--) : (u = a[v + 1], S.logger.log("SN just loaded, load next one: " + u.sn))
                } else u = null;
                return u
            }
        }, {
            key: "_loadFragmentOrKey", value: function (e) {
                var t = e.frag, r = e.level, i = e.levelDetails, a = e.pos, n = e.bufferEnd, s = this.hls, o = s.config;
                if (null == t.decryptdata.uri || null != t.decryptdata.key) {
                    if (S.logger.log("Loading " + t.sn + " of [" + i.startSN + " ," + i.endSN + "],level " + r + ", currentTime:" + a.toFixed(3) + ",bufferEnd:" + n.toFixed(3)), void 0 !== this.fragLoadIdx ? this.fragLoadIdx++ : this.fragLoadIdx = 0, t.loadCounter) {
                        t.loadCounter++;
                        var l = o.fragLoadingLoopThreshold;
                        if (t.loadCounter > l && Math.abs(this.fragLoadIdx - t.loadIdx) < l)return s.trigger(p.default.ERROR, {
                            type: _.ErrorTypes.MEDIA_ERROR,
                            details: _.ErrorDetails.FRAG_LOOP_LOADING_ERROR,
                            fatal: !1,
                            frag: t
                        }), !1
                    } else t.loadCounter = 1;
                    return t.loadIdx = this.fragLoadIdx, this.fragCurrent = t, this.startFragRequested = !0, t.autoLevel = s.autoLevelEnabled, t.bitrateTest = this.bitrateTest, s.trigger(p.default.FRAG_LOADING, {frag: t}), this.state = T.FRAG_LOADING, !0
                }
                S.logger.log("Loading key for " + t.sn + " of [" + i.startSN + " ," + i.endSN + "],level " + r), this.state = T.KEY_LOADING, s.trigger(p.default.KEY_LOADING, {frag: t})
            }
        }, {
            key: "getBufferRange", value: function (e) {
                var t, r, i = this.bufferRange;
                if (i)for (t = i.length - 1; t >= 0; t--)if (r = i[t], e >= r.start && e <= r.end)return r;
                return null
            }
        }, {
            key: "followingBufferRange", value: function (e) {
                return e ? this.getBufferRange(e.end + .5) : null
            }
        }, {
            key: "_checkFragmentChanged", value: function () {
                var e, t, r = this.media;
                if (r && r.readyState && r.seeking === !1 && (t = r.currentTime, t > r.playbackRate * this.lastCurrentTime && (this.lastCurrentTime = t), c.default.isBuffered(r, t) ? e = this.getBufferRange(t) : c.default.isBuffered(r, t + .1) && (e = this.getBufferRange(t + .1)), e)) {
                    var i = e.frag;
                    i !== this.fragPlaying && (this.fragPlaying = i, this.hls.trigger(p.default.FRAG_CHANGED, {frag: i}))
                }
            }
        }, {
            key: "immediateLevelSwitch", value: function () {
                if (S.logger.log("immediateLevelSwitch"), !this.immediateSwitch) {
                    this.immediateSwitch = !0;
                    var e = this.media, t = void 0;
                    e ? (t = e.paused, e.pause()) : t = !0, this.previouslyPaused = t
                }
                var r = this.fragCurrent;
                r && r.loader && r.loader.abort(), this.fragCurrent = null, this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold, this.state = T.BUFFER_FLUSHING, this.hls.trigger(p.default.BUFFER_FLUSHING, {
                    startOffset: 0,
                    endOffset: Number.POSITIVE_INFINITY
                })
            }
        }, {
            key: "immediateLevelSwitchEnd", value: function () {
                var e = this.media;
                e && e.buffered.length && (this.immediateSwitch = !1, c.default.isBuffered(e, e.currentTime) && (e.currentTime -= 1e-4), this.previouslyPaused || e.play())
            }
        }, {
            key: "nextLevelSwitch", value: function () {
                var e = this.media;
                if (e && e.readyState) {
                    var t = void 0, r = void 0, i = void 0;
                    if (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold, r = this.getBufferRange(e.currentTime), r && r.start > 1 && (this.state = T.BUFFER_FLUSHING, this.hls.trigger(p.default.BUFFER_FLUSHING, {
                            startOffset: 0,
                            endOffset: r.start - 1
                        })), e.paused)t = 0; else {
                        var a = this.hls.nextLoadLevel, n = this.levels[a], s = this.fragLastKbps;
                        t = s && this.fragCurrent ? this.fragCurrent.duration * n.bitrate / (1e3 * s) + 1 : 0
                    }
                    if (i = this.getBufferRange(e.currentTime + t), i && (i = this.followingBufferRange(i))) {
                        var o = this.fragCurrent;
                        o && o.loader && o.loader.abort(), this.fragCurrent = null, this.state = T.BUFFER_FLUSHING, this.hls.trigger(p.default.BUFFER_FLUSHING, {
                            startOffset: i.start,
                            endOffset: Number.POSITIVE_INFINITY
                        })
                    }
                }
            }
        }, {
            key: "onMediaAttached", value: function (e) {
                var t = this.media = this.mediaBuffer = e.media;
                this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener("seeking", this.onvseeking), t.addEventListener("seeked", this.onvseeked), t.addEventListener("ended", this.onvended);
                var r = this.config;
                this.levels && r.autoStartLoad && this.hls.startLoad(r.startPosition)
            }
        }, {
            key: "onMediaDetaching", value: function () {
                var e = this.media;
                e && e.ended && (S.logger.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
                var t = this.levels;
                t && t.forEach(function (e) {
                    e.details && e.details.fragments.forEach(function (e) {
                        e.loadCounter = void 0
                    })
                }), e && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("seeked", this.onvseeked), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = null, this.loadedmetadata = !1, this.stopLoad()
            }
        }, {
            key: "onMediaSeeking", value: function () {
                var e = this.media, t = e ? e.currentTime : void 0, r = this.config;
                if (S.logger.log("media seeking to " + t.toFixed(3)), this.state === T.FRAG_LOADING) {
                    var i = c.default.bufferInfo(e, t, this.config.maxBufferHole), a = this.fragCurrent;
                    if (0 === i.len && a) {
                        var n = r.maxFragLookUpTolerance, s = a.start - n, o = a.start + a.duration + n;
                        t < s || t > o ? (a.loader && (S.logger.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), a.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = T.IDLE) : S.logger.log("seeking outside of buffer but within currently loaded fragment range")
                    }
                } else this.state === T.ENDED && (this.state = T.IDLE);
                e && (this.lastCurrentTime = t), this.state !== T.FRAG_LOADING && void 0 !== this.fragLoadIdx && (this.fragLoadIdx += 2 * r.fragLoadingLoopThreshold), this.tick()
            }
        }, {
            key: "onMediaSeeked", value: function () {
                S.logger.log("media seeked to " + this.media.currentTime.toFixed(3)), this.tick()
            }
        }, {
            key: "onMediaEnded", value: function () {
                S.logger.log("media ended"), this.startPosition = this.lastCurrentTime = 0
            }
        }, {
            key: "onManifestLoading", value: function () {
                S.logger.log("trigger BUFFER_RESET"), this.hls.trigger(p.default.BUFFER_RESET), this.bufferRange = [], this.stalled = !1, this.startPosition = this.lastCurrentTime = 0
            }
        }, {
            key: "onManifestParsed", value: function (e) {
                var t, r = !1, i = !1;
                e.levels.forEach(function (e) {
                    t = e.audioCodec, t && (t.indexOf("mp4a.40.2") !== -1 && (r = !0), t.indexOf("mp4a.40.5") !== -1 && (i = !0))
                }), this.audioCodecSwitch = r && i, this.audioCodecSwitch && S.logger.log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = e.levels, this.startLevelLoaded = !1, this.startFragRequested = !1;
                var a = this.config;
                a.autoStartLoad && this.hls.startLoad(a.startPosition)
            }
        }, {
            key: "onLevelLoaded", value: function (e) {
                var t = e.details, r = e.level, i = this.levels[r], a = t.totalduration, n = 0;
                if (S.logger.log("level " + r + " loaded [" + t.startSN + "," + t.endSN + "],duration:" + a), this.levelLastLoaded = r, t.live) {
                    var s = i.details;
                    s && t.fragments.length > 0 ? (b.default.mergeDetails(s, t), n = t.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(n, s), t.PTSKnown ? S.logger.log("live playlist sliding:" + n.toFixed(3)) : S.logger.log("live playlist - outdated PTS, unknown sliding")) : (t.PTSKnown = !1, S.logger.log("live playlist - first load, unknown sliding"))
                } else t.PTSKnown = !1;
                if (i.details = t, this.hls.trigger(p.default.LEVEL_UPDATED, {
                        details: t,
                        level: r
                    }), this.startFragRequested === !1) {
                    if (this.startPosition === -1 || this.lastCurrentTime === -1) {
                        var o = t.startTimeOffset;
                        isNaN(o) ? t.live ? (this.startPosition = this.computeLivePosition(n, t), S.logger.log("configure startPosition to " + this.startPosition)) : this.startPosition = 0 : (o < 0 && (S.logger.log("negative start time offset " + o + ", count from end of last fragment"), o = n + a + o), S.logger.log("start time offset found in playlist, adjust startPosition to " + o), this.startPosition = o)
                    }
                    this.nextLoadPosition = this.startPosition
                }
                this.state === T.WAITING_LEVEL && (this.state = T.IDLE), this.tick()
            }
        }, {
            key: "onKeyLoaded", value: function () {
                this.state === T.KEY_LOADING && (this.state = T.IDLE, this.tick())
            }
        }, {
            key: "onFragLoaded", value: function (e) {
                var t = this.fragCurrent, r = e.frag;
                if (this.state === T.FRAG_LOADING && t && "main" === r.type && r.level === t.level && r.sn === t.sn) {
                    var i = e.stats, a = this.levels[t.level], n = a.details;
                    if (S.logger.log("Loaded  " + t.sn + " of [" + n.startSN + " ," + n.endSN + "],level " + t.level), this.bitrateTest = !1, r.bitrateTest === !0 && this.hls.nextLoadLevel)this.state = T.IDLE, this.startFragRequested = !1, i.tparsed = i.tbuffered = performance.now(), this.hls.trigger(p.default.FRAG_BUFFERED, {
                        stats: i,
                        frag: t,
                        id: "main"
                    }), this.tick(); else {
                        this.state = T.PARSING, this.stats = i;
                        var s = n.totalduration, o = isNaN(t.startDTS) ? t.start : t.startDTS, l = t.level, u = t.sn, d = this.config.defaultAudioCodec || a.audioCodec;
                        this.audioCodecSwap && (S.logger.log("swapping playlist audio codec"), void 0 === d && (d = this.lastAudioCodec), d && (d = d.indexOf("mp4a.40.5") !== -1 ? "mp4a.40.2" : "mp4a.40.5")), this.pendingAppending = 0, S.logger.log("Parsing " + u + " of [" + n.startSN + " ," + n.endSN + "],level " + l + ", cc " + t.cc);
                        var f = this.demuxer;
                        f || (f = this.demuxer = new v.default(this.hls, "main"));
                        var c = n.PTSKnown || !n.live;
                        f.push(e.payload, d, a.videoCodec, o, t.cc, l, u, s, t.decryptdata, c)
                    }
                }
                this.fragLoadError = 0
            }
        }, {
            key: "onFragParsingInitSegment", value: function (e) {
                var t = this.fragCurrent;
                if (t && "main" === e.id && e.sn === t.sn && e.level === t.level && this.state === T.PARSING) {
                    var r, i, a = e.tracks;
                    if (a.audio && this.altAudio && delete a.audio, i = a.audio) {
                        var n = this.levels[this.level].audioCodec, s = navigator.userAgent.toLowerCase();
                        n && this.audioCodecSwap && (S.logger.log("swapping playlist audio codec"), n = n.indexOf("mp4a.40.5") !== -1 ? "mp4a.40.2" : "mp4a.40.5"), this.audioCodecSwitch && 1 !== i.metadata.channelCount && s.indexOf("firefox") === -1 && (n = "mp4a.40.5"), s.indexOf("android") !== -1 && (n = "mp4a.40.2", S.logger.log("Android: force audio codec to" + n)), i.levelCodec = n, i.id = e.id
                    }
                    if (i = a.video, i && (i.levelCodec = this.levels[this.level].videoCodec, i.id = e.id), e.unique) {
                        var o = {codec: "", levelCodec: ""};
                        for (r in e.tracks)i = a[r], o.container = i.container, o.codec && (o.codec += ",", o.levelCodec += ","), i.codec && (o.codec += i.codec), i.levelCodec && (o.levelCodec += i.levelCodec);
                        a = {audiovideo: o}
                    }
                    this.hls.trigger(p.default.BUFFER_CODECS, a);
                    for (r in a) {
                        i = a[r], S.logger.log("main track:" + r + ",container:" + i.container + ",codecs[level/parsed]=[" + i.levelCodec + "/" + i.codec + "]");
                        var l = i.initSegment;
                        l && (this.pendingAppending++, this.hls.trigger(p.default.BUFFER_APPENDING, {
                            type: r,
                            data: l,
                            parent: "main",
                            content: "initSegment"
                        }))
                    }
                    this.tick()
                }
            }
        }, {
            key: "onFragParsingData", value: function (e) {
                var t = this, r = this.fragCurrent;
                if (r && "main" === e.id && e.sn === r.sn && e.level === r.level && ("audio" !== e.type || !this.altAudio) && this.state === T.PARSING) {
                    var i = this.levels[this.level], a = this.fragCurrent;
                    S.logger.log("Parsed " + e.type + ",PTS:[" + e.startPTS.toFixed(3) + "," + e.endPTS.toFixed(3) + "],DTS:[" + e.startDTS.toFixed(3) + "/" + e.endDTS.toFixed(3) + "],nb:" + e.nb + ",dropped:" + (e.dropped || 0));
                    var n = b.default.updateFragPTSDTS(i.details, a.sn, e.startPTS, e.endPTS, e.startDTS, e.endDTS), s = this.hls;
                    s.trigger(p.default.LEVEL_PTS_UPDATED, {
                        details: i.details,
                        level: this.level,
                        drift: n
                    }), "video" === e.type && (a.dropped = e.dropped), [e.data1, e.data2].forEach(function (r) {
                        r && (t.pendingAppending++, s.trigger(p.default.BUFFER_APPENDING, {
                            type: e.type,
                            data: r,
                            parent: "main",
                            content: "data"
                        }))
                    }), this.nextLoadPosition = e.endPTS, this.bufferRange.push({
                        type: e.type,
                        start: e.startPTS,
                        end: e.endPTS,
                        frag: a
                    }), this.tick()
                }
            }
        }, {
            key: "onFragParsed", value: function (e) {
                var t = this.fragCurrent;
                t && "main" === e.id && e.sn === t.sn && e.level === t.level && this.state === T.PARSING && (this.stats.tparsed = performance.now(), this.state = T.PARSED, this._checkAppendedParsed())
            }
        }, {
            key: "onAudioTrackSwitch", value: function (e) {
                var t = !!e.url;
                if (t)this.videoBuffer && this.mediaBuffer !== this.videoBuffer && (S.logger.log("switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = this.videoBuffer); else if (this.mediaBuffer !== this.media) {
                    S.logger.log("switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                    var r = this.fragCurrent;
                    r.loader && (S.logger.log("switching to main audio track, cancel main fragment load"), r.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = T.IDLE
                }
                this.altAudio = t
            }
        }, {
            key: "onBufferCreated", value: function (e) {
                var t = e.tracks, r = void 0, i = void 0, a = !1;
                for (var n in t) {
                    var s = t[n];
                    "main" === s.id ? (i = n, r = s, "video" === n && (this.videoBuffer = t[n].buffer)) : a = !0
                }
                a && r ? (S.logger.log("alternate track found, use " + i + ".buffered to schedule main fragment loading"), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
            }
        }, {
            key: "onBufferAppended", value: function (e) {
                if ("main" === e.parent)switch (this.state) {
                    case T.PARSING:
                    case T.PARSED:
                        this.pendingAppending--, this._checkAppendedParsed()
                }
            }
        }, {
            key: "_checkAppendedParsed", value: function () {
                if (this.state === T.PARSED && 0 === this.pendingAppending) {
                    var e = this.fragCurrent, t = this.stats;
                    if (e) {
                        this.fragPrevious = e, t.tbuffered = performance.now(), this.fragLastKbps = Math.round(8 * t.total / (t.tbuffered - t.tfirst)), this.hls.trigger(p.default.FRAG_BUFFERED, {
                            stats: t,
                            frag: e,
                            id: "main"
                        });
                        var r = this.mediaBuffer ? this.mediaBuffer : this.media;
                        S.logger.log("main buffered : " + R.default.toString(r.buffered)), this.state = T.IDLE
                    }
                    this.tick()
                }
            }
        }, {
            key: "onError", value: function (e) {
                var t = e.frag || this.fragCurrent;
                if (!t || "main" === t.type) {
                    var r = this.media, i = r && c.default.isBuffered(r, r.currentTime) && c.default.isBuffered(r, r.currentTime + .5);
                    switch (e.details) {
                        case _.ErrorDetails.FRAG_LOAD_ERROR:
                        case _.ErrorDetails.FRAG_LOAD_TIMEOUT:
                        case _.ErrorDetails.KEY_LOAD_ERROR:
                        case _.ErrorDetails.KEY_LOAD_TIMEOUT:
                            if (!e.fatal) {
                                var a = this.fragLoadError;
                                a ? a++ : a = 1;
                                var n = this.config;
                                if (a <= n.fragLoadingMaxRetry || i || t.autoLevel && t.level) {
                                    this.fragLoadError = a, t.loadCounter = 0;
                                    var s = Math.min(Math.pow(2, a - 1) * n.fragLoadingRetryDelay, n.fragLoadingMaxRetryTimeout);
                                    S.logger.warn("mediaController: frag loading failed, retry in " + s + " ms"), this.retryDate = performance.now() + s, this.state = T.FRAG_LOADING_WAITING_RETRY
                                } else S.logger.error("mediaController: " + e.details + " reaches max retry, redispatch as fatal ..."), e.fatal = !0, this.hls.trigger(p.default.ERROR, e), this.state = T.ERROR
                            }
                            break;
                        case _.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
                            e.fatal || (i ? (this._reduceMaxBufferLength(t.duration), this.state = T.IDLE) : t.autoLevel && 0 !== t.level || (e.fatal = !0, this.hls.trigger(p.default.ERROR, e), this.state = T.ERROR));
                            break;
                        case _.ErrorDetails.LEVEL_LOAD_ERROR:
                        case _.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                            this.state !== T.ERROR && (e.fatal ? (this.state = T.ERROR, S.logger.warn("streamController: " + e.details + ",switch to " + this.state + " state ...")) : this.state === T.WAITING_LEVEL && (this.state = T.IDLE));
                            break;
                        case _.ErrorDetails.BUFFER_FULL_ERROR:
                            this.state !== T.PARSING && this.state !== T.PARSED || (i ? (this._reduceMaxBufferLength(t.duration), this.state = T.IDLE) : (S.logger.warn("buffer full error also media.currentTime is not buffered, flush everything"), this.fragCurrent = null, this.state = T.PAUSED, this.hls.trigger(p.default.BUFFER_FLUSHING, {
                                startOffset: 0,
                                endOffset: Number.POSITIVE_INFINITY
                            })))
                    }
                }
            }
        }, {
            key: "_reduceMaxBufferLength", value: function (e) {
                var t = this.config;
                t.maxMaxBufferLength >= e && (t.maxMaxBufferLength /= 2, S.logger.warn("reduce max buffer length to " + t.maxMaxBufferLength + "s and switch to IDLE state"), this.fragLoadIdx += 2 * t.fragLoadingLoopThreshold)
            }
        }, {
            key: "_checkBuffer", value: function () {
                var e = this.media;
                if (e && e.readyState) {
                    var t = e.currentTime, r = e.buffered;
                    if (!this.loadedmetadata && r.length) {
                        this.loadedmetadata = !0;
                        var i = this.startPosition, a = c.default.isBuffered(e, i);
                        t === i && a || (S.logger.log("target start position:" + i), a || (i = r.start(0), S.logger.log("target start position not buffered, seek to buffered.start(0) " + i)), S.logger.log("adjust currentTime from " + t + " to " + i), e.currentTime = i)
                    } else if (this.immediateSwitch)this.immediateLevelSwitchEnd(); else {
                        var n = c.default.bufferInfo(e, t, 0), s = !(e.paused || e.ended || 0 === e.buffered.length), o = .5, l = t > e.playbackRate * this.lastCurrentTime, u = this.config;
                        if (this.stalled && l && (this.stalled = !1, S.logger.log("playback not stuck anymore @" + t)), s && n.len <= o && (l ? (o = 0, this.seekHoleNudgeDuration = 0) : this.stalled ? this.seekHoleNudgeDuration += u.seekHoleNudgeDuration : (this.seekHoleNudgeDuration = 0, S.logger.log("playback seems stuck @" + t), this.hls.trigger(p.default.ERROR, {
                                type: _.ErrorTypes.MEDIA_ERROR,
                                details: _.ErrorDetails.BUFFER_STALLED_ERROR,
                                fatal: !1
                            }), this.stalled = !0), n.len <= o)) {
                            var d = n.nextStart, f = d - t;
                            if (d && f < u.maxSeekHole && f > 0) {
                                S.logger.log("adjust currentTime from " + e.currentTime + " to next buffered @ " + d + " + nudge " + this.seekHoleNudgeDuration);
                                var h = d + this.seekHoleNudgeDuration - e.currentTime;
                                e.currentTime = d + this.seekHoleNudgeDuration, this.hls.trigger(p.default.ERROR, {
                                    type: _.ErrorTypes.MEDIA_ERROR,
                                    details: _.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                                    fatal: !1,
                                    hole: h
                                })
                            }
                        }
                    }
                }
            }
        }, {
            key: "onFragLoadEmergencyAborted", value: function () {
                this.state = T.IDLE, this.loadedmetadata || (this.startFragRequested = !1), this.tick()
            }
        }, {
            key: "onBufferFlushed", value: function () {
                var e = this.mediaBuffer ? this.mediaBuffer : this.media, t = this.bufferRange, r = [], i = void 0, a = void 0;
                for (a = 0; a < t.length; a++)i = t[a], c.default.isBuffered(e, (i.start + i.end) / 2) && r.push(i);
                this.bufferRange = r, this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold, this.state = T.IDLE, this.fragPrevious = null
            }
        }, {
            key: "swapAudioCodec", value: function () {
                this.audioCodecSwap = !this.audioCodecSwap
            }
        }, {
            key: "computeLivePosition", value: function (e, t) {
                var r = void 0 !== this.config.liveSyncDuration ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * t.targetduration;
                return e + Math.max(0, t.totalduration - r)
            }
        }, {
            key: "state", set: function (e) {
                if (this.state !== e) {
                    var t = this.state;
                    this._state = e, S.logger.log("engine state transition from " + t + " to " + e), this.hls.trigger(p.default.STREAM_STATE_TRANSITION, {
                        previousState: t,
                        nextState: e
                    })
                }
            }, get: function () {
                return this._state
            }
        }, {
            key: "currentLevel", get: function () {
                var e = this.media;
                if (e) {
                    var t = this.getBufferRange(e.currentTime);
                    if (t)return t.frag.level
                }
                return -1
            }
        }, {
            key: "nextBufferRange", get: function () {
                var e = this.media;
                return e ? this.followingBufferRange(this.getBufferRange(e.currentTime)) : null
            }
        }, {
            key: "nextLevel", get: function () {
                var e = this.nextBufferRange;
                return e ? e.frag.level : -1
            }
        }, {
            key: "liveSyncPosition", get: function () {
                return this._liveSyncPosition
            }, set: function (e) {
                this._liveSyncPosition = e
            }
        }]), t
    }(m.default);
    t.default = A
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = r(43), v = i(h), g = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.MEDIA_ATTACHING, d.default.MEDIA_DETACHING, d.default.FRAG_PARSING_USERDATA, d.default.MANIFEST_LOADING, d.default.FRAG_LOADED, d.default.LEVEL_SWITCH));
            if (r.hls = e, r.config = e.config, r.enabled = !0, r.Cues = e.config.cueHandler, r.config.enableCEA708Captions) {
                var i = r, s = {
                    newCue: function (e, t, r) {
                        if (!i.textTrack1) {
                            var a = i.getExistingTrack("1");
                            if (a) {
                                i.textTrack1 = a, i.clearCurrentCues(i.textTrack1);
                                var n = new window.Event("addtrack");
                                n.track = i.textTrack1, i.media.dispatchEvent(n)
                            } else i.textTrack1 = i.createTextTrack("captions", "English", "en"), i.textTrack1.textTrack1 = !0
                        }
                        i.Cues.newCue(i.textTrack1, e, t, r)
                    }
                }, o = {
                    newCue: function (e, t, r) {
                        if (!i.textTrack2) {
                            var a = i.getExistingTrack("2");
                            if (a) {
                                i.textTrack2 = a, i.clearCurrentCues(i.textTrack2);
                                var n = new window.Event("addtrack");
                                n.track = i.textTrack2, i.media.dispatchEvent(n)
                            } else i.textTrack2 = i.createTextTrack("captions", "Spanish", "es"), i.textTrack2.textTrack2 = !0
                        }
                        i.Cues.newCue(i.textTrack2, e, t, r)
                    }
                };
                r.cea608Parser = new v.default(0, s, o)
            }
            return r
        }

        return s(t, e), l(t, [{
            key: "clearCurrentCues", value: function (e) {
                if (e && e.cues)for (; e.cues.length > 0;)e.removeCue(e.cues[0])
            }
        }, {
            key: "getExistingTrack", value: function (e) {
                var t = this.media;
                if (t)for (var r = 0; r < t.textTracks.length; r++) {
                    var i = t.textTracks[r], a = "textTrack" + e;
                    if (i[a] === !0)return i
                }
                return null
            }
        }, {
            key: "createTextTrack", value: function (e, t, r) {
                if (this.media)return this.media.addTextTrack(e, t, r)
            }
        }, {
            key: "destroy", value: function () {
                c.default.prototype.destroy.call(this)
            }
        }, {
            key: "onMediaAttaching", value: function (e) {
                this.media = e.media
            }
        }, {
            key: "onMediaDetaching", value: function () {
            }
        }, {
            key: "onManifestLoading", value: function () {
                this.lastPts = Number.NEGATIVE_INFINITY
            }
        }, {
            key: "onLevelSwitch", value: function () {
                "NONE" === this.hls.currentLevel.closedCaptions ? this.enabled = !1 : this.enabled = !0
            }
        }, {
            key: "onFragLoaded", value: function (e) {
                if ("main" === e.frag.type) {
                    var t = e.frag.start;
                    t <= this.lastPts && (this.clearCurrentCues(this.textTrack1), this.clearCurrentCues(this.textTrack2)), this.lastPts = t
                }
            }
        }, {
            key: "onFragParsingUserdata", value: function (e) {
                if (this.enabled && this.config.enableCEA708Captions)for (var t = 0; t < e.samples.length; t++) {
                    var r = this.extractCea608Data(e.samples[t].bytes);
                    this.cea608Parser.addData(e.samples[t].pts, r)
                }
            }
        }, {
            key: "extractCea608Data", value: function (e) {
                for (var t, r, i, a, n, s = 31 & e[0], o = 2, l = [], u = 0; u < s; u++)t = e[o++], r = 127 & e[o++], i = 127 & e[o++], a = 0 !== (4 & t), n = 3 & t, 0 === r && 0 === i || a && 0 === n && (l.push(r), l.push(i));
                return l
            }
        }]), t
    }(c.default);
    t.default = g
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e(t) {
            r(this, e), this.aesIV = t
        }

        return i(e, [{
            key: "decrypt", value: function (e, t) {
                return window.crypto.subtle.decrypt({name: "AES-CBC", iv: this.aesIV}, t, e)
            }
        }]), e
    }();
    t.default = a
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e() {
            r(this, e), this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [], this.subMix[0] = new Uint32Array(256), this.subMix[1] = new Uint32Array(256), this.subMix[2] = new Uint32Array(256), this.subMix[3] = new Uint32Array(256), this.invSubMix = [], this.invSubMix[0] = new Uint32Array(256), this.invSubMix[1] = new Uint32Array(256), this.invSubMix[2] = new Uint32Array(256), this.invSubMix[3] = new Uint32Array(256), this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable()
        }

        return i(e, [{
            key: "uint8ArrayToUint32Array_", value: function (e) {
                for (var t = new DataView(e), r = new Uint32Array(4), i = 0; i < r.length; i++)r[i] = t.getUint32(4 * i);
                return r
            }
        }, {
            key: "initTable", value: function () {
                var e = this.sBox, t = this.invSBox, r = this.subMix[0], i = this.subMix[1], a = this.subMix[2], n = this.subMix[3], s = this.invSubMix[0], o = this.invSubMix[1], l = this.invSubMix[2], u = this.invSubMix[3], d = new Uint32Array(256), f = 0, c = 0, h = 0;
                for (h = 0; h < 256; h++)h < 128 ? d[h] = h << 1 : d[h] = h << 1 ^ 283;
                for (h = 0; h < 256; h++) {
                    var v = c ^ c << 1 ^ c << 2 ^ c << 3 ^ c << 4;
                    v = v >>> 8 ^ 255 & v ^ 99, e[f] = v, t[v] = f;
                    var g = d[f], p = d[g], y = d[p], m = 257 * d[v] ^ 16843008 * v;
                    r[f] = m << 24 | m >>> 8, i[f] = m << 16 | m >>> 16, a[f] = m << 8 | m >>> 24, n[f] = m, m = 16843009 * y ^ 65537 * p ^ 257 * g ^ 16843008 * f, s[v] = m << 24 | m >>> 8, o[v] = m << 16 | m >>> 16, l[v] = m << 8 | m >>> 24, u[v] = m, f ? (f = g ^ d[d[d[y ^ g]]], c ^= d[d[c]]) : f = c = 1
                }
            }
        }, {
            key: "expandKey", value: function (e) {
                for (var t = this.uint8ArrayToUint32Array_(e), r = !0, i = 0; i < t.length && r;)r = t[i] === this.key[i], i++;
                if (!r) {
                    this.key = t;
                    var a = this.keySize = t.length;
                    if (4 !== a && 6 !== a && 8 !== a)throw new Error("Invalid aes key size=" + a);
                    var n = this.ksRows = 4 * (a + 6 + 1), s = void 0, o = void 0, l = this.keySchedule = new Uint32Array(this.ksRows).fill(0), u = this.invKeySchedule = new Uint32Array(this.ksRows).fill(0), d = this.sBox, f = this.rcon, c = this.invSubMix[0], h = this.invSubMix[1], v = this.invSubMix[2], g = this.invSubMix[3], p = void 0, y = void 0;
                    for (s = 0; s < n; s++)s < a ? p = l[s] = t[s] : (y = p, s % a === 0 ? (y = y << 8 | y >>> 24, y = d[y >>> 24] << 24 | d[y >>> 16 & 255] << 16 | d[y >>> 8 & 255] << 8 | d[255 & y], y ^= f[s / a | 0] << 24) : a > 6 && s % a === 4 && (y = d[y >>> 24] << 24 | d[y >>> 16 & 255] << 16 | d[y >>> 8 & 255] << 8 | d[255 & y]), l[s] = p = (l[s - a] ^ y) >>> 0);
                    for (o = 0; o < n; o++)s = n - o, y = 3 & o ? l[s] : l[s - 4], o < 4 || s <= 4 ? u[o] = y : u[o] = c[d[y >>> 24]] ^ h[d[y >>> 16 & 255]] ^ v[d[y >>> 8 & 255]] ^ g[d[255 & y]], u[o] = u[o] >>> 0
                }
            }
        }, {
            key: "networkToHostOrderSwap", value: function (e) {
                return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
            }
        }, {
            key: "decrypt", value: function (e, t, r) {
                for (var i, a, n = this.keySize + 6, s = this.invKeySchedule, o = this.invSBox, l = this.invSubMix[0], u = this.invSubMix[1], d = this.invSubMix[2], f = this.invSubMix[3], c = this.uint8ArrayToUint32Array_(r), h = c[0], v = c[1], g = c[2], p = c[3], y = new Int32Array(e), m = new Int32Array(y.length), E = void 0, b = void 0, k = void 0, R = void 0, _ = void 0, S = void 0, T = void 0, A = void 0, L = void 0, w = void 0, D = void 0, O = void 0; t < y.length;) {
                    for (L = this.networkToHostOrderSwap(y[t]), w = this.networkToHostOrderSwap(y[t + 1]), D = this.networkToHostOrderSwap(y[t + 2]), O = this.networkToHostOrderSwap(y[t + 3]), _ = L ^ s[0], S = O ^ s[1], T = D ^ s[2], A = w ^ s[3], i = 4, a = 1; a < n; a++)E = l[_ >>> 24] ^ u[S >> 16 & 255] ^ d[T >> 8 & 255] ^ f[255 & A] ^ s[i], b = l[S >>> 24] ^ u[T >> 16 & 255] ^ d[A >> 8 & 255] ^ f[255 & _] ^ s[i + 1], k = l[T >>> 24] ^ u[A >> 16 & 255] ^ d[_ >> 8 & 255] ^ f[255 & S] ^ s[i + 2], R = l[A >>> 24] ^ u[_ >> 16 & 255] ^ d[S >> 8 & 255] ^ f[255 & T] ^ s[i + 3], _ = E, S = b, T = k, A = R, i += 4;
                    E = o[_ >>> 24] << 24 ^ o[S >> 16 & 255] << 16 ^ o[T >> 8 & 255] << 8 ^ o[255 & A] ^ s[i], b = o[S >>> 24] << 24 ^ o[T >> 16 & 255] << 16 ^ o[A >> 8 & 255] << 8 ^ o[255 & _] ^ s[i + 1], k = o[T >>> 24] << 24 ^ o[A >> 16 & 255] << 16 ^ o[_ >> 8 & 255] << 8 ^ o[255 & S] ^ s[i + 2], R = o[A >>> 24] << 24 ^ o[_ >> 16 & 255] << 16 ^ o[S >> 8 & 255] << 8 ^ o[255 & T] ^ s[i + 3], i += 3, m[t] = this.networkToHostOrderSwap(E ^ h), m[t + 1] = this.networkToHostOrderSwap(R ^ v), m[t + 2] = this.networkToHostOrderSwap(k ^ g), m[t + 3] = this.networkToHostOrderSwap(b ^ p), h = L, v = w, g = D, p = O, t += 4
                }
                return m.buffer
            }
        }, {
            key: "destroy", value: function () {
                this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0
            }
        }]), e
    }();
    t.default = a
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(24), o = i(s), l = r(27), u = i(l), d = r(25), f = i(d), c = r(3), h = r(1), v = function () {
        function e(t) {
            a(this, e), this.hls = t;
            try {
                var r = window ? window.crypto : crypto;
                this.subtle = r.subtle || r.webkitSubtle
            } catch (e) {
            }
            this.disableWebCrypto = !this.supportsWebCrypto()
        }

        return n(e, [{
            key: "supportsWebCrypto", value: function () {
                return this.subtle && "https:" === window.location.protocol
            }
        }, {
            key: "decrypt", value: function (e, t, r, i) {
                var a = this;
                this.disableWebCrypto && this.hls.config.enableSoftwareAES ? (h.logger.log("decrypting by JavaScript Implementation"), this.decryptor || (this.decryptor = new f.default), this.decryptor.expandKey(t), i(this.decryptor.decrypt(e, 0, r))) : (h.logger.log("decrypting by WebCrypto API"), this.key !== t && (this.key = t, this.fastAesKey = new u.default(t)), this.fastAesKey.expandKey().then(function (t) {
                    var a = new o.default(r);
                    a.decrypt(e, t).then(function (e) {
                        i(e)
                    })
                }).catch(function (n) {
                    a.onWebCryptoError(n, e, t, r, i)
                }))
            }
        }, {
            key: "onWebCryptoError", value: function (e, t, r, i, a) {
                this.hls.config.enableSoftwareAES ? (h.logger.log("disabling to use WebCrypto API"), this.disableWebCrypto = !0, this.decrypt(t, r, i, a)) : (h.logger.error("decrypting error : " + e.message), this.hls.trigger(Event.ERROR, {
                    type: c.ErrorTypes.MEDIA_ERROR,
                    details: c.ErrorDetails.FRAG_DECRYPT_ERROR,
                    fatal: !0,
                    reason: e.message
                }))
            }
        }, {
            key: "destroy", value: function () {
                this.decryptor && (this.decryptor.destroy(), this.decryptor = void 0)
            }
        }]), e
    }();
    t.default = v
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e(t) {
            r(this, e), this.key = t
        }

        return i(e, [{
            key: "expandKey", value: function () {
                return window.crypto.subtle.importKey("raw", this.key, {name: "AES-CBC"}, !1, ["encrypt", "decrypt"])
            }
        }]), e
    }();
    t.default = a
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(6), o = i(s), l = r(1), u = r(31), d = i(u), f = function () {
        function e(t, r, i, n) {
            a(this, e), this.observer = t, this.id = r, this.remuxerClass = i, this.config = n, this.remuxer = new this.remuxerClass(t, r, n), this.insertDiscontinuity()
        }

        return n(e, [{
            key: "insertDiscontinuity", value: function () {
                this._aacTrack = {
                    container: "audio/adts",
                    type: "audio",
                    id: -1,
                    sequenceNumber: 0,
                    samples: [],
                    len: 0
                }
            }
        }, {
            key: "push", value: function (e, t, r, i, a, n, s, u, f) {
                var c, h, v, g, p, y, m, E, b, k, R = new d.default(e), _ = 90 * R.timeStamp, S = !1;
                for (a !== this.lastCC ? (l.logger.log(this.id + " discontinuity detected"), this.lastCC = a, this.insertDiscontinuity(), this.remuxer.switchLevel(), this.remuxer.insertDiscontinuity()) : n !== this.lastLevel ? (l.logger.log("audio track switch detected"), this.lastLevel = n, this.remuxer.switchLevel(), this.insertDiscontinuity()) : s === this.lastSN + 1 && (S = !0), c = this._aacTrack, this.lastSN = s, this.lastLevel = n, y = R.length, b = e.length; y < b - 1 && (255 !== e[y] || 240 !== (240 & e[y + 1])); y++);
                for (c.audiosamplerate || (h = o.default.getAudioConfig(this.observer, e, y, t), c.config = h.config, c.audiosamplerate = h.samplerate, c.channelCount = h.channelCount, c.codec = h.codec, c.duration = u, l.logger.log("parsed codec:" + c.codec + ",rate:" + h.samplerate + ",nb channel:" + h.channelCount)), p = 0, g = 9216e4 / c.audiosamplerate; y + 5 < b && (m = 1 & e[y + 1] ? 7 : 9, v = (3 & e[y + 3]) << 11 | e[y + 4] << 3 | (224 & e[y + 5]) >>> 5, v -= m, v > 0 && y + m + v <= b);)for (E = _ + p * g, k = {
                    unit: e.subarray(y + m, y + m + v),
                    pts: E,
                    dts: E
                }, c.samples.push(k), c.len += v, y += v + m, p++; y < b - 1 && (255 !== e[y] || 240 !== (240 & e[y + 1])); y++);
                this.remuxer.remux(n, s, this._aacTrack, {samples: []}, {
                    samples: [{
                        pts: _,
                        dts: _,
                        unit: R.payload
                    }]
                }, {samples: []}, i, S, f)
            }
        }, {
            key: "destroy", value: function () {
            }
        }], [{
            key: "probe", value: function (e) {
                var t, r, i = new d.default(e);
                if (i.hasTimeStamp)for (t = i.length, r = e.length; t < r - 1; t++)if (255 === e[t] && 240 === (240 & e[t + 1]))return !0;
                return !1
            }
        }]), e
    }();
    t.default = f
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var a = r(7), n = i(a), s = r(2), o = i(s), l = r(1), u = r(12), d = i(u), f = function (e) {
        var t = new d.default;
        t.trigger = function (e) {
            for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)i[a - 1] = arguments[a];
            t.emit.apply(t, [e, e].concat(i))
        }, t.off = function (e) {
            for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)i[a - 1] = arguments[a];
            t.removeListener.apply(t, [e].concat(i))
        };
        var r = function (t, r) {
            e.postMessage({event: t, data: r})
        };
        e.addEventListener("message", function (i) {
            var a = i.data;
            switch (a.cmd) {
                case"init":
                    var s = JSON.parse(a.config);
                    e.demuxer = new n.default(t, a.id, a.typeSupported, s);
                    try {
                        (0, l.enableLogs)(s.debug)
                    } catch (e) {
                        console.warn("demuxerWorker: unable to enable logs")
                    }
                    r("init", null);
                    break;
                case"demux":
                    e.demuxer.push(new Uint8Array(a.data), a.audioCodec, a.videoCodec, a.timeOffset, a.cc, a.level, a.sn, a.duration, a.accurateTimeOffset)
            }
        }), t.on(o.default.FRAG_PARSING_INIT_SEGMENT, r), t.on(o.default.FRAG_PARSED, r), t.on(o.default.ERROR, r), t.on(o.default.FRAG_PARSING_METADATA, r), t.on(o.default.FRAG_PARSING_USERDATA, r), t.on(o.default.FRAG_PARSING_DATA, function (t, r) {
            var i = r.data1.buffer, a = r.data2.buffer;
            delete r.data1, delete r.data2, e.postMessage({event: t, data: r, data1: i, data2: a}, [i, a])
        })
    };
    t.default = f
}, function (e, t, r) {
    "use strict";
    function i(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var a = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), n = r(1), s = function () {
        function e(t) {
            i(this, e), this.data = t, this.bytesAvailable = this.data.byteLength, this.word = 0, this.bitsAvailable = 0
        }

        return a(e, [{
            key: "loadWord", value: function () {
                var e = this.data.byteLength - this.bytesAvailable, t = new Uint8Array(4), r = Math.min(4, this.bytesAvailable);
                if (0 === r)throw new Error("no bytes available");
                t.set(this.data.subarray(e, e + r)), this.word = new DataView(t.buffer).getUint32(0), this.bitsAvailable = 8 * r, this.bytesAvailable -= r
            }
        }, {
            key: "skipBits", value: function (e) {
                var t;
                this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e >> 3, e -= t >> 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e)
            }
        }, {
            key: "readBits", value: function (e) {
                var t = Math.min(this.bitsAvailable, e), r = this.word >>> 32 - t;
                return e > 32 && n.logger.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0 ? this.word <<= t : this.bytesAvailable > 0 && this.loadWord(), t = e - t, t > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r
            }
        }, {
            key: "skipLZ", value: function () {
                var e;
                for (e = 0; e < this.bitsAvailable; ++e)if (0 !== (this.word & 2147483648 >>> e))return this.word <<= e, this.bitsAvailable -= e, e;
                return this.loadWord(), e + this.skipLZ()
            }
        }, {
            key: "skipUEG", value: function () {
                this.skipBits(1 + this.skipLZ())
            }
        }, {
            key: "skipEG", value: function () {
                this.skipBits(1 + this.skipLZ())
            }
        }, {
            key: "readUEG", value: function () {
                var e = this.skipLZ();
                return this.readBits(e + 1) - 1
            }
        }, {
            key: "readEG", value: function () {
                var e = this.readUEG();
                return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
            }
        }, {
            key: "readBoolean", value: function () {
                return 1 === this.readBits(1)
            }
        }, {
            key: "readUByte", value: function () {
                return this.readBits(8)
            }
        }, {
            key: "readUShort", value: function () {
                return this.readBits(16)
            }
        }, {
            key: "readUInt", value: function () {
                return this.readBits(32)
            }
        }, {
            key: "skipScalingList", value: function (e) {
                var t, r, i = 8, a = 8;
                for (t = 0; t < e; t++)0 !== a && (r = this.readEG(), a = (i + r + 256) % 256), i = 0 === a ? i : a
            }
        }, {
            key: "readSPS", value: function () {
                var e, t, r, i, a, n, s, o, l, u = 0, d = 0, f = 0, c = 0, h = 1;
                if (this.readUByte(), e = this.readUByte(), t = this.readBits(5), this.skipBits(3), r = this.readUByte(), this.skipUEG(), 100 === e || 110 === e || 122 === e || 244 === e || 44 === e || 83 === e || 86 === e || 118 === e || 128 === e) {
                    var v = this.readUEG();
                    if (3 === v && this.skipBits(1), this.skipUEG(), this.skipUEG(), this.skipBits(1), this.readBoolean())for (o = 3 !== v ? 8 : 12, l = 0; l < o; l++)this.readBoolean() && (l < 6 ? this.skipScalingList(16) : this.skipScalingList(64))
                }
                this.skipUEG();
                var g = this.readUEG();
                if (0 === g)this.readUEG(); else if (1 === g)for (this.skipBits(1), this.skipEG(), this.skipEG(), i = this.readUEG(), l = 0; l < i; l++)this.skipEG();
                if (this.skipUEG(), this.skipBits(1), a = this.readUEG(), n = this.readUEG(), s = this.readBits(1), 0 === s && this.skipBits(1), this.skipBits(1), this.readBoolean() && (u = this.readUEG(), d = this.readUEG(), f = this.readUEG(), c = this.readUEG()), this.readBoolean() && this.readBoolean()) {
                    var p = void 0, y = this.readUByte();
                    switch (y) {
                        case 1:
                            p = [1, 1];
                            break;
                        case 2:
                            p = [12, 11];
                            break;
                        case 3:
                            p = [10, 11];
                            break;
                        case 4:
                            p = [16, 11];
                            break;
                        case 5:
                            p = [40, 33];
                            break;
                        case 6:
                            p = [24, 11];
                            break;
                        case 7:
                            p = [20, 11];
                            break;
                        case 8:
                            p = [32, 11];
                            break;
                        case 9:
                            p = [80, 33];
                            break;
                        case 10:
                            p = [18, 11];
                            break;
                        case 11:
                            p = [15, 11];
                            break;
                        case 12:
                            p = [64, 33];
                            break;
                        case 13:
                            p = [160, 99];
                            break;
                        case 14:
                            p = [4, 3];
                            break;
                        case 15:
                            p = [3, 2];
                            break;
                        case 16:
                            p = [2, 1];
                            break;
                        case 255:
                            p = [this.readUByte() << 8 | this.readUByte(), this.readUByte() << 8 | this.readUByte()]
                    }
                    p && (h = p[0] / p[1])
                }
                return {
                    width: Math.ceil((16 * (a + 1) - 2 * u - 2 * d) * h),
                    height: (2 - s) * (n + 1) * 16 - (s ? 2 : 4) * (f + c)
                }
            }
        }, {
            key: "readSliceType", value: function () {
                return this.readUByte(), this.readUEG(), this.readUEG()
            }
        }]), e
    }();
    t.default = s
}, function (e, t, r) {
    "use strict";
    function i(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var a = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), n = r(1), s = function () {
        function e(t) {
            i(this, e), this._hasTimeStamp = !1;
            for (var r, a, s, o, l, u, d, f, c = 0; ;)if (d = this.readUTF(t, c, 3), c += 3, "ID3" === d)c += 3, r = 127 & t[c++], a = 127 & t[c++], s = 127 & t[c++], o = 127 & t[c++], l = (r << 21) + (a << 14) + (s << 7) + o, u = c + l, this._parseID3Frames(t, c, u), c = u; else {
                if ("3DI" !== d)return c -= 3, f = c, void(f && (this.hasTimeStamp || n.logger.warn("ID3 tag found, but no timestamp"), this._length = f, this._payload = t.subarray(0, f)));
                c += 7, n.logger.log("3DI footer found, end: " + c)
            }
        }

        return a(e, [{
            key: "readUTF", value: function (e, t, r) {
                var i = "", a = t, n = t + r;
                do i += String.fromCharCode(e[a++]); while (a < n);
                return i
            }
        }, {
            key: "_parseID3Frames", value: function (e, t, r) {
                for (var i, a, s, o, l; t + 8 <= r;)switch (i = this.readUTF(e, t, 4), t += 4, a = e[t++] << 24 + e[t++] << 16 + e[t++] << 8 + e[t++], o = e[t++] << 8 + e[t++], s = t, i) {
                    case"PRIV":
                        if ("com.apple.streaming.transportStreamTimestamp" === this.readUTF(e, t, 44)) {
                            t += 44, t += 4;
                            var u = 1 & e[t++];
                            this._hasTimeStamp = !0, l = ((e[t++] << 23) + (e[t++] << 15) + (e[t++] << 7) + e[t++]) / 45, u && (l += 47721858.84), l = Math.round(l), n.logger.trace("ID3 timestamp found: " + l), this._timeStamp = l
                        }
                }
            }
        }, {
            key: "hasTimeStamp", get: function () {
                return this._hasTimeStamp
            }
        }, {
            key: "timeStamp", get: function () {
                return this._timeStamp
            }
        }, {
            key: "length", get: function () {
                return this._length
            }
        }, {
            key: "payload", get: function () {
                return this._payload
            }
        }]), e
    }();
    t.default = s
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(6), o = i(s), l = r(2), u = i(l), d = r(30), f = i(d), c = r(1), h = r(3), v = function () {
        function e(t, r, i, n) {
            a(this, e), this.observer = t, this.id = r, this.remuxerClass = i, this.config = n, this.lastCC = 0, this.remuxer = new this.remuxerClass(t, r, n)
        }

        return n(e, [{
            key: "switchLevel", value: function () {
                this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = {
                    container: "video/mp2t",
                    type: "video",
                    id: -1,
                    sequenceNumber: 0,
                    samples: [],
                    len: 0,
                    dropped: 0
                }, this._aacTrack = {
                    container: "video/mp2t",
                    type: "audio",
                    id: -1,
                    sequenceNumber: 0,
                    samples: [],
                    len: 0
                }, this._id3Track = {
                    type: "id3",
                    id: -1,
                    sequenceNumber: 0,
                    samples: [],
                    len: 0
                }, this._txtTrack = {
                    type: "text",
                    id: -1,
                    sequenceNumber: 0,
                    samples: [],
                    len: 0
                }, this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.remuxer.switchLevel()
            }
        }, {
            key: "insertDiscontinuity", value: function () {
                this.switchLevel(), this.remuxer.insertDiscontinuity()
            }
        }, {
            key: "push", value: function (e, t, r, i, a, n, s, o, l) {
                var d, f, v, g, p, y, m = e.length, E = this.remuxer.passthrough, b = !1;
                this.audioCodec = t, this.videoCodec = r, this._duration = o, this.contiguous = !1, this.accurateTimeOffset = l, a !== this.lastCC && (c.logger.log("discontinuity detected"), this.insertDiscontinuity(), this.lastCC = a), n !== this.lastLevel ? (c.logger.log("level switch detected"), this.switchLevel(), this.lastLevel = n) : s === this.lastSN + 1 && (this.contiguous = !0), this.lastSN = s;
                var k = this.pmtParsed, R = this._avcTrack, _ = this._aacTrack, S = this._id3Track, T = R.id, A = _.id, L = S.id, w = this._pmtId, D = R.pesData, O = _.pesData, P = S.pesData, C = this._parsePAT, I = this._parsePMT, x = this._parsePES, M = this._parseAVCPES.bind(this), N = this._parseAACPES.bind(this), F = this._parseID3PES.bind(this);
                for (m -= m % 188, d = 0; d < m; d += 188)if (71 === e[d]) {
                    if (f = !!(64 & e[d + 1]), v = ((31 & e[d + 1]) << 8) + e[d + 2], g = (48 & e[d + 3]) >> 4, g > 1) {
                        if (p = d + 5 + e[d + 4], p === d + 188)continue
                    } else p = d + 4;
                    switch (v) {
                        case T:
                            if (f) {
                                if (D && (y = x(D)) && (M(y, !1), E && R.codec && (A === -1 || _.codec)))return void this.remux(n, s, e, i);
                                D = {data: [], size: 0}
                            }
                            D && (D.data.push(e.subarray(p, d + 188)), D.size += d + 188 - p);
                            break;
                        case A:
                            if (f) {
                                if (O && (y = x(O)) && (N(y), E && _.codec && (T === -1 || R.codec)))return void this.remux(n, s, e, i);
                                O = {data: [], size: 0}
                            }
                            O && (O.data.push(e.subarray(p, d + 188)), O.size += d + 188 - p);
                            break;
                        case L:
                            f && (P && (y = x(P)) && F(y), P = {
                                data: [],
                                size: 0
                            }), P && (P.data.push(e.subarray(p, d + 188)), P.size += d + 188 - p);
                            break;
                        case 0:
                            f && (p += e[p] + 1), w = this._pmtId = C(e, p);
                            break;
                        case w:
                            f && (p += e[p] + 1);
                            var U = I(e, p);
                            T = U.avc, T > 0 && (R.id = T), A = U.aac, A > 0 && (_.id = A), L = U.id3, L > 0 && (S.id = L), b && !k && (c.logger.log("reparse from beginning"), b = !1, d = -188), k = this.pmtParsed = !0;
                            break;
                        case 17:
                        case 8191:
                            break;
                        default:
                            b = !0
                    }
                } else this.observer.trigger(u.default.ERROR, {
                    type: h.ErrorTypes.MEDIA_ERROR,
                    id: this.id,
                    details: h.ErrorDetails.FRAG_PARSING_ERROR,
                    fatal: !1,
                    reason: "TS packet did not start with 0x47"
                });
                D && (y = x(D)) ? (M(y, !0), R.pesData = null) : R.pesData = D, O && (y = x(O)) ? (N(y), _.pesData = null) : (O && O.size && c.logger.log("last AAC PES packet truncated,might overlap between fragments"), _.pesData = O), P && (y = x(P)) ? (F(y), S.pesData = null) : S.pesData = P, this.remux(n, s, null, i)
            }
        }, {
            key: "remux", value: function (e, t, r, i) {
                var a = this._avcTrack, n = a.samples, s = n.reduce(function (e, t) {
                    var r = t.units.units.reduce(function (e, t) {
                        return {len: e.len + t.data.length, nbNalu: e.nbNalu + 1}
                    }, {len: 0, nbNalu: 0});
                    return t.length = r.len, {len: e.len + r.len, nbNalu: e.nbNalu + r.nbNalu}
                }, {len: 0, nbNalu: 0});
                a.len = s.len, a.nbNalu = s.nbNalu, this.remuxer.remux(e, t, this._aacTrack, this._avcTrack, this._id3Track, this._txtTrack, i, this.contiguous, this.accurateTimeOffset, r)
            }
        }, {
            key: "destroy", value: function () {
                this.switchLevel(), this._initPTS = this._initDTS = void 0, this._duration = 0
            }
        }, {
            key: "_parsePAT", value: function (e, t) {
                return (31 & e[t + 10]) << 8 | e[t + 11]
            }
        }, {
            key: "_parsePMT", value: function (e, t) {
                var r, i, a, n, s = {aac: -1, avc: -1, id3: -1};
                for (r = (15 & e[t + 1]) << 8 | e[t + 2], i = t + 3 + r - 4, a = (15 & e[t + 10]) << 8 | e[t + 11], t += 12 + a; t < i;) {
                    switch (n = (31 & e[t + 1]) << 8 | e[t + 2], e[t]) {
                        case 15:
                            s.aac === -1 && (s.aac = n);
                            break;
                        case 21:
                            s.id3 === -1 && (s.id3 = n);
                            break;
                        case 27:
                            s.avc === -1 && (s.avc = n);
                            break;
                        case 36:
                            c.logger.warn("HEVC stream type found, not supported for now");
                            break;
                        default:
                            c.logger.log("unkown stream type:" + e[t])
                    }
                    t += ((15 & e[t + 3]) << 8 | e[t + 4]) + 5
                }
                return s
            }
        }, {
            key: "_parsePES", value: function (e) {
                var t, r, i, a, n, s, o, l, u, d = 0, f = e.data;
                if (!e || 0 === e.size)return null;
                for (; f[0].length < 19 && f.length > 1;) {
                    var c = new Uint8Array(f[0].length + f[1].length);
                    c.set(f[0]), c.set(f[1], f[0].length), f[0] = c, f.splice(1, 1)
                }
                if (t = f[0], i = (t[0] << 16) + (t[1] << 8) + t[2], 1 === i) {
                    if (a = (t[4] << 8) + t[5], a && a > e.size - 6)return null;
                    for (r = t[7], 192 & r && (o = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2, o > 4294967295 && (o -= 8589934592), 64 & r ? (l = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2, l > 4294967295 && (l -= 8589934592)) : l = o), n = t[8], u = n + 9, e.size -= u, s = new Uint8Array(e.size); f.length;) {
                        t = f.shift();
                        var h = t.byteLength;
                        if (u) {
                            if (u > h) {
                                u -= h;
                                continue
                            }
                            t = t.subarray(u), h -= u, u = 0
                        }
                        s.set(t, d), d += h
                    }
                    return a && (a -= n + 3), {data: s, pts: o, dts: l, len: a}
                }
                return null
            }
        }, {
            key: "pushAccesUnit", value: function (e, t) {
                e.units.units.length && (!this.config.forceKeyFrameOnDiscontinuity || e.key === !0 || t.sps && (t.samples.length || this.contiguous) ? t.samples.push(e) : t.dropped++), e.debug.length && c.logger.log(e.pts + "/" + e.dts + ":" + e.debug + "," + e.units.length)
            }
        }, {
            key: "_parseAVCPES", value: function (e, t) {
                var r, i, a, n = this, s = this._avcTrack, o = this._parseAVCNALu(e.data), l = !1, u = this.avcSample;
                e.data = null, o.forEach(function (t) {
                    switch (t.type) {
                        case 1:
                            i = !0, l && u && (u.debug += "NDR ");
                            break;
                        case 5:
                            i = !0, u || (u = n.avcSample = n._createAVCSample(!0, e.pts, e.dts, "")), l && (u.debug += "IDR "), u.key = !0;
                            break;
                        case 6:
                            i = !0, l && u && (u.debug += "SEI "), r = new f.default(n.discardEPB(t.data)), r.readUByte();
                            for (var o = 0, d = 0, c = !1, h = 0; !c && r.bytesAvailable > 1;) {
                                o = 0;
                                do h = r.readUByte(), o += h; while (255 === h);
                                d = 0;
                                do h = r.readUByte(), d += h; while (255 === h);
                                if (4 === o && 0 !== r.bytesAvailable) {
                                    c = !0;
                                    var v = r.readUByte();
                                    if (181 === v) {
                                        var g = r.readUShort();
                                        if (49 === g) {
                                            var p = r.readUInt();
                                            if (1195456820 === p) {
                                                var y = r.readUByte();
                                                if (3 === y) {
                                                    var m = r.readUByte(), E = r.readUByte(), b = 31 & m, k = [m, E];
                                                    for (a = 0; a < b; a++)k.push(r.readUByte()), k.push(r.readUByte()), k.push(r.readUByte());
                                                    n._insertSampleInOrder(n._txtTrack.samples, {
                                                        type: 3,
                                                        pts: e.pts,
                                                        bytes: k
                                                    })
                                                }
                                            }
                                        }
                                    }
                                } else if (d < r.bytesAvailable)for (a = 0; a < d; a++)r.readUByte()
                            }
                            break;
                        case 7:
                            if (i = !0, l && u && (u.debug += "SPS "), !s.sps) {
                                r = new f.default(t.data);
                                var R = r.readSPS();
                                s.width = R.width, s.height = R.height, s.sps = [t.data], s.duration = n._duration;
                                var _ = t.data.subarray(1, 4), S = "avc1.";
                                for (a = 0; a < 3; a++) {
                                    var T = _[a].toString(16);
                                    T.length < 2 && (T = "0" + T), S += T
                                }
                                s.codec = S
                            }
                            break;
                        case 8:
                            i = !0, l && u && (u.debug += "PPS "), s.pps || (s.pps = [t.data]);
                            break;
                        case 9:
                            i = !1, u && n.pushAccesUnit(u, s), u = n.avcSample = n._createAVCSample(!1, e.pts, e.dts, l ? "AUD " : "");
                            break;
                        case 12:
                            i = !1;
                            break;
                        default:
                            i = !1, u && (u.debug += "unknown NAL " + t.type + " ")
                    }
                    if (u && i) {
                        var A = u.units;
                        A.units.push(t)
                    }
                }), t && u && (this.pushAccesUnit(u, s), this.avcSample = null)
            }
        }, {
            key: "_createAVCSample", value: function (e, t, r, i) {
                return {key: e, pts: t, dts: r, units: {units: [], length: 0}, debug: i}
            }
        }, {
            key: "_insertSampleInOrder", value: function (e, t) {
                var r = e.length;
                if (r > 0) {
                    if (t.pts >= e[r - 1].pts)e.push(t); else for (var i = r - 1; i >= 0; i--)if (t.pts < e[i].pts) {
                        e.splice(i, 0, t);
                        break
                    }
                } else e.push(t)
            }
        }, {
            key: "_getLastNalUnit", value: function () {
                var e = this.avcSample, t = void 0;
                if (!e || 0 === e.units.units.length) {
                    var r = this._avcTrack, i = r.samples;
                    e = i[i.length - 1]
                }
                if (e) {
                    var a = e.units.units;
                    t = a[a.length - 1]
                }
                return t
            }
        }, {
            key: "_parseAVCNALu", value: function (e) {
                for (var t, r, i, a, n, s = 0, o = e.byteLength, l = this._avcTrack, u = l.naluState || 0, d = u, f = [], c = -1; s < o;)switch (t = e[s++], u) {
                    case 0:
                        0 === t && (u = 1);
                        break;
                    case 1:
                        u = 0 === t ? 2 : 0;
                        break;
                    case 2:
                    case 3:
                        if (0 === t)u = 3; else if (1 === t) {
                            if (c >= 0)i = {data: e.subarray(c, s - u - 1), type: n}, f.push(i); else {
                                var h = this._getLastNalUnit();
                                if (h && (d && s <= 4 - d && h.state && (h.data = h.data.subarray(0, h.data.byteLength - d)), r = s - u - 1, r > 0)) {
                                    var v = new Uint8Array(h.data.byteLength + r);
                                    v.set(h.data, 0), v.set(e.subarray(0, r), h.data.byteLength), h.data = v
                                }
                            }
                            s < o ? (a = 31 & e[s], c = s, n = a, u = 0) : u = -1
                        } else u = 0;
                        break;
                    case-1:
                        c = 0, n = 31 & t, u = 0
                }
                if (c >= 0 && u >= 0 && (i = {data: e.subarray(c, o), type: n, state: u}, f.push(i)), 0 === f.length) {
                    var g = this._getLastNalUnit();
                    if (g) {
                        var p = new Uint8Array(g.data.byteLength + e.byteLength);
                        p.set(g.data, 0), p.set(e, g.data.byteLength), g.data = p
                    }
                }
                return l.naluState = u, f
            }
        }, {
            key: "discardEPB", value: function (e) {
                for (var t, r, i = e.byteLength, a = [], n = 1; n < i - 2;)0 === e[n] && 0 === e[n + 1] && 3 === e[n + 2] ? (a.push(n + 2), n += 2) : n++;
                if (0 === a.length)return e;
                t = i - a.length, r = new Uint8Array(t);
                var s = 0;
                for (n = 0; n < t; s++, n++)s === a[0] && (s++, a.shift()), r[n] = e[s];
                return r
            }
        }, {
            key: "_parseAACPES", value: function (e) {
                var t, r, i, a, n, s, l, d, f, v = this._aacTrack, g = e.data, p = e.pts, y = 0, m = this.aacOverFlow, E = this.aacLastPTS;
                if (m) {
                    var b = new Uint8Array(m.byteLength + g.byteLength);
                    b.set(m, 0), b.set(g, m.byteLength), g = b
                }
                for (n = y, d = g.length; n < d - 1 && (255 !== g[n] || 240 !== (240 & g[n + 1])); n++);
                if (n) {
                    var k, R;
                    if (n < d - 1 ? (k = "AAC PES did not start with ADTS header,offset:" + n, R = !1) : (k = "no ADTS header found in AAC PES", R = !0), c.logger.warn("parsing error:" + k), this.observer.trigger(u.default.ERROR, {
                            type: h.ErrorTypes.MEDIA_ERROR,
                            id: this.id,
                            details: h.ErrorDetails.FRAG_PARSING_ERROR,
                            fatal: R,
                            reason: k
                        }), R)return
                }
                if (v.audiosamplerate || (t = o.default.getAudioConfig(this.observer, g, n, this.audioCodec), v.config = t.config, v.audiosamplerate = t.samplerate, v.channelCount = t.channelCount, v.codec = t.codec, v.duration = this._duration, c.logger.log("parsed codec:" + v.codec + ",rate:" + t.samplerate + ",nb channel:" + t.channelCount)), a = 0, i = 9216e4 / v.audiosamplerate, m && E) {
                    var _ = E + i;
                    Math.abs(_ - p) > 1 && (c.logger.log("AAC: align PTS for overlapping frames by " + Math.round((_ - p) / 90)), p = _)
                }
                for (; n + 5 < d && (s = 1 & g[n + 1] ? 7 : 9, r = (3 & g[n + 3]) << 11 | g[n + 4] << 3 | (224 & g[n + 5]) >>> 5, r -= s, r > 0 && n + s + r <= d);)for (l = p + a * i, f = {
                    unit: g.subarray(n + s, n + s + r),
                    pts: l,
                    dts: l
                }, v.samples.push(f), v.len += r, n += r + s, a++; n < d - 1 && (255 !== g[n] || 240 !== (240 & g[n + 1])); n++);
                m = n < d ? g.subarray(n, d) : null, this.aacOverFlow = m, this.aacLastPTS = l
            }
        }, {
            key: "_parseID3PES", value: function (e) {
                this._id3Track.samples.push(e)
            }
        }], [{
            key: "probe", value: function (e) {
                return e.length >= 564 && 71 === e[0] && 71 === e[188] && 71 === e[376]
            }
        }]), e
    }();
    t.default = v
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function");
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e() {
            r(this, e)
        }

        return i(e, null, [{
            key: "getSilentFrame", value: function (e) {
                return 1 === e ? new Uint8Array([0, 200, 0, 128, 35, 128]) : 2 === e ? new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]) : 3 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]) : 4 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]) : 5 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]) : 6 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]) : null
            }
        }]), e
    }();
    t.default = a
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(2), o = i(s), l = r(3), u = r(38), d = i(u), f = r(36), c = i(f), h = r(14), v = i(h), g = r(17), p = i(g), y = r(18), m = i(y), E = r(15), b = i(E), k = r(22), R = i(k), _ = r(21), S = i(_), T = r(23), A = i(T), L = r(20), w = i(L), D = r(16), O = i(D), P = r(1), C = r(47), I = i(C), x = r(12), M = i(x), N = r(37), F = i(N), U = r(44), G = i(U), B = function () {
        function e() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            a(this, e);
            var r = e.DefaultConfig;
            if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration))throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
            for (var i in r)i in t || (t[i] = r[i]);
            if (void 0 !== t.liveMaxLatencyDurationCount && t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
            if (void 0 !== t.liveMaxLatencyDuration && (t.liveMaxLatencyDuration <= t.liveSyncDuration || void 0 === t.liveSyncDuration))throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
            (0, P.enableLogs)(t.debug), this.config = t;
            var n = this.observer = new M.default;
            n.trigger = function (e) {
                for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i];
                n.emit.apply(n, [e, e].concat(r))
            }, n.off = function (e) {
                for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i];
                n.removeListener.apply(n, [e].concat(r))
            }, this.on = n.on.bind(n), this.off = n.off.bind(n), this.trigger = n.trigger.bind(n), this.playlistLoader = new d.default(this), this.fragmentLoader = new c.default(this), this.levelController = new S.default(this), this.abrController = new t.abrController(this), this.bufferController = new t.bufferController(this), this.capLevelController = new t.capLevelController(this), this.fpsController = new t.fpsController(this), this.streamController = new t.streamController(this), this.audioStreamController = new t.audioStreamController(this), this.timelineController = new t.timelineController(this), this.audioTrackController = new O.default(this), this.keyLoader = new F.default(this)
        }

        return n(e, null, [{
            key: "isSupported", value: function () {
                return window.MediaSource = window.MediaSource || window.WebKitMediaSource, window.MediaSource && "function" == typeof window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"')
            }
        }, {
            key: "version", get: function () {
                return "__VERSION__"
            }
        }, {
            key: "Events", get: function () {
                return o.default
            }
        }, {
            key: "ErrorTypes", get: function () {
                return l.ErrorTypes
            }
        }, {
            key: "ErrorDetails", get: function () {
                return l.ErrorDetails
            }
        }, {
            key: "DefaultConfig", get: function () {
                return e.defaultConfig || (e.defaultConfig = {
                    autoStartLoad: !0,
                    startPosition: -1,
                    defaultAudioCodec: void 0,
                    debug: !1,
                    capLevelOnFPSDrop: !1,
                    capLevelToPlayerSize: !1,
                    initialLiveManifestSize: 1,
                    maxBufferLength: 30,
                    maxBufferSize: 6e7,
                    maxBufferHole: .5,
                    maxSeekHole: 2,
                    seekHoleNudgeDuration: .01,
                    stalledInBufferedNudgeThreshold: 10,
                    maxFragLookUpTolerance: .2,
                    liveSyncDurationCount: 3,
                    liveMaxLatencyDurationCount: 1 / 0,
                    liveSyncDuration: void 0,
                    liveMaxLatencyDuration: void 0,
                    maxMaxBufferLength: 600,
                    enableWorker: !0,
                    enableSoftwareAES: !0,
                    manifestLoadingTimeOut: 1e4,
                    manifestLoadingMaxRetry: 1,
                    manifestLoadingRetryDelay: 1e3,
                    manifestLoadingMaxRetryTimeout: 64e3,
                    startLevel: void 0,
                    levelLoadingTimeOut: 1e4,
                    levelLoadingMaxRetry: 4,
                    levelLoadingRetryDelay: 1e3,
                    levelLoadingMaxRetryTimeout: 64e3,
                    fragLoadingTimeOut: 2e4,
                    fragLoadingMaxRetry: 6,
                    fragLoadingRetryDelay: 1e3,
                    fragLoadingMaxRetryTimeout: 64e3,
                    fragLoadingLoopThreshold: 3,
                    startFragPrefetch: !1,
                    fpsDroppedMonitoringPeriod: 5e3,
                    fpsDroppedMonitoringThreshold: .2,
                    appendErrorMaxRetry: 3,
                    loader: I.default,
                    fLoader: void 0,
                    pLoader: void 0,
                    xhrSetup: void 0,
                    fetchSetup: void 0,
                    abrController: v.default,
                    bufferController: p.default,
                    capLevelController: m.default,
                    fpsController: w.default,
                    streamController: R.default,
                    audioStreamController: b.default,
                    timelineController: A.default,
                    cueHandler: G.default,
                    enableCEA708Captions: !0,
                    enableMP2TPassThrough: !1,
                    stretchShortVideoTrack: !1,
                    forceKeyFrameOnDiscontinuity: !0,
                    abrEwmaFastLive: 3,
                    abrEwmaSlowLive: 9,
                    abrEwmaFastVoD: 3,
                    abrEwmaSlowVoD: 9,
                    abrEwmaDefaultEstimate: 5e5,
                    abrBandWidthFactor: .95,
                    abrBandWidthUpFactor: .7,
                    maxStarvationDelay: 4,
                    maxLoadingDelay: 4,
                    minAutoBitrate: 0
                }), e.defaultConfig
            }, set: function (t) {
                e.defaultConfig = t
            }
        }]), n(e, [{
            key: "destroy", value: function () {
                P.logger.log("destroy"), this.trigger(o.default.DESTROYING), this.detachMedia(), this.playlistLoader.destroy(), this.fragmentLoader.destroy(), this.levelController.destroy(), this.abrController.destroy(), this.bufferController.destroy(), this.capLevelController.destroy(), this.fpsController.destroy(), this.streamController.destroy(), this.audioStreamController.destroy(), this.timelineController.destroy(), this.audioTrackController.destroy(), this.keyLoader.destroy(), this.url = null, this.observer.removeAllListeners()
            }
        }, {
            key: "attachMedia", value: function (e) {
                P.logger.log("attachMedia"), this.media = e, this.trigger(o.default.MEDIA_ATTACHING, {media: e})
            }
        }, {
            key: "detachMedia", value: function () {
                P.logger.log("detachMedia"), this.trigger(o.default.MEDIA_DETACHING), this.media = null
            }
        }, {
            key: "loadSource", value: function (e) {
                P.logger.log("loadSource:" + e), this.url = e, this.trigger(o.default.MANIFEST_LOADING, {url: e})
            }
        }, {
            key: "startLoad", value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1;
                P.logger.log("startLoad"), this.levelController.startLoad(), this.streamController.startLoad(e), this.audioStreamController.startLoad(e)
            }
        }, {
            key: "stopLoad", value: function () {
                P.logger.log("stopLoad"), this.levelController.stopLoad(), this.streamController.stopLoad(), this.audioStreamController.stopLoad()
            }
        }, {
            key: "swapAudioCodec", value: function () {
                P.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec()
            }
        }, {
            key: "recoverMediaError", value: function () {
                P.logger.log("recoverMediaError");
                var e = this.media;
                this.detachMedia(), this.attachMedia(e)
            }
        }, {
            key: "levels", get: function () {
                return this.levelController.levels
            }
        }, {
            key: "currentLevel", get: function () {
                return this.streamController.currentLevel
            }, set: function (e) {
                P.logger.log("set currentLevel:" + e), this.loadLevel = e, this.streamController.immediateLevelSwitch()
            }
        }, {
            key: "nextLevel", get: function () {
                return this.streamController.nextLevel
            }, set: function (e) {
                P.logger.log("set nextLevel:" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch()
            }
        }, {
            key: "loadLevel", get: function () {
                return this.levelController.level
            }, set: function (e) {
                P.logger.log("set loadLevel:" + e), this.levelController.manualLevel = e
            }
        }, {
            key: "nextLoadLevel", get: function () {
                return this.levelController.nextLoadLevel
            }, set: function (e) {
                this.levelController.nextLoadLevel = e
            }
        }, {
            key: "firstLevel", get: function () {
                return this.levelController.firstLevel
            }, set: function (e) {
                P.logger.log("set firstLevel:" + e), this.levelController.firstLevel = e
            }
        }, {
            key: "startLevel", get: function () {
                return this.levelController.startLevel
            }, set: function (e) {
                P.logger.log("set startLevel:" + e), this.levelController.startLevel = e
            }
        }, {
            key: "autoLevelCapping", get: function () {
                return this.abrController.autoLevelCapping
            }, set: function (e) {
                P.logger.log("set autoLevelCapping:" + e), this.abrController.autoLevelCapping = e
            }
        }, {
            key: "autoLevelEnabled", get: function () {
                return this.levelController.manualLevel === -1
            }
        }, {
            key: "manualLevel", get: function () {
                return this.levelController.manualLevel
            }
        }, {
            key: "audioTracks", get: function () {
                return this.audioTrackController.audioTracks
            }
        }, {
            key: "audioTrack", get: function () {
                return this.audioTrackController.audioTrack
            }, set: function (e) {
                this.audioTrackController.audioTrack = e
            }
        }, {
            key: "liveSyncPosition", get: function () {
                return this.streamController.liveSyncPosition
            }
        }]), e
    }();
    t.default = B
}, function (e, t, r) {
    "use strict";
    e.exports = r(34).default
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = r(3), v = r(1), g = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.FRAG_LOADING));
            return r.loaders = {}, r
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                var e = this.loaders;
                for (var t in e) {
                    var r = e[t];
                    r && r.destroy()
                }
                this.loaders = {}, c.default.prototype.destroy.call(this)
            }
        }, {
            key: "onFragLoading", value: function (e) {
                var t = e.frag, r = t.type, i = this.loaders[r], a = this.hls.config;
                t.loaded = 0, i && (v.logger.warn("abort previous fragment loader for type:" + r), i.abort()), i = this.loaders[r] = t.loader = "undefined" != typeof a.fLoader ? new a.fLoader(a) : new a.loader(a);
                var n = void 0, s = void 0, o = void 0;
                n = {url: t.url, frag: t, responseType: "arraybuffer", progressData: !1};
                var l = t.byteRangeStartOffset, u = t.byteRangeEndOffset;
                isNaN(l) || isNaN(u) || (n.rangeStart = l, n.rangeEnd = u), s = {
                    timeout: a.fragLoadingTimeOut,
                    maxRetry: 0,
                    retryDelay: 0,
                    maxRetryDelay: a.fragLoadingMaxRetryTimeout
                }, o = {
                    onSuccess: this.loadsuccess.bind(this),
                    onError: this.loaderror.bind(this),
                    onTimeout: this.loadtimeout.bind(this),
                    onProgress: this.loadprogress.bind(this)
                }, i.load(n, s, o)
            }
        }, {
            key: "loadsuccess", value: function (e, t, r) {
                var i = e.data, a = r.frag;
                a.loader = void 0, this.loaders[a.type] = void 0, this.hls.trigger(d.default.FRAG_LOADED, {
                    payload: i,
                    frag: a,
                    stats: t
                })
            }
        }, {
            key: "loaderror", value: function (e, t) {
                var r = t.loader;
                r && r.abort(), this.loaders[t.type] = void 0, this.hls.trigger(d.default.ERROR, {
                    type: h.ErrorTypes.NETWORK_ERROR,
                    details: h.ErrorDetails.FRAG_LOAD_ERROR,
                    fatal: !1,
                    frag: t.frag,
                    response: e
                })
            }
        }, {
            key: "loadtimeout", value: function (e, t) {
                var r = t.loader;
                r && r.abort(), this.loaders[t.type] = void 0, this.hls.trigger(d.default.ERROR, {
                    type: h.ErrorTypes.NETWORK_ERROR,
                    details: h.ErrorDetails.FRAG_LOAD_TIMEOUT,
                    fatal: !1,
                    frag: t.frag
                })
            }
        }, {
            key: "loadprogress", value: function (e, t, r) {
                var i = t.frag;
                i.loaded = e.loaded, this.hls.trigger(d.default.FRAG_LOAD_PROGRESS, {frag: i, stats: e})
            }
        }]), t
    }(c.default);
    t.default = g
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(2), d = i(u), f = r(4), c = i(f), h = r(3), v = r(1), g = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, d.default.KEY_LOADING));
            return r.loaders = {}, r.decryptkey = null, r.decrypturl = null, r
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                for (var e in this.loaders) {
                    var t = this.loaders[e];
                    t && t.destroy()
                }
                this.loaders = {}, c.default.prototype.destroy.call(this)
            }
        }, {
            key: "onKeyLoading", value: function (e) {
                var t = e.frag, r = t.type, i = this.loaders[r], a = t.decryptdata, n = a.uri;
                if (n !== this.decrypturl || null === this.decryptkey) {
                    var s = this.hls.config;
                    i && (v.logger.warn("abort previous key loader for type:" + r), i.abort()), t.loader = this.loaders[r] = new s.loader(s), this.decrypturl = n, this.decryptkey = null;
                    var o = void 0, l = void 0, u = void 0;
                    o = {url: n, frag: t, responseType: "arraybuffer"}, l = {
                        timeout: s.fragLoadingTimeOut,
                        maxRetry: s.fragLoadingMaxRetry,
                        retryDelay: s.fragLoadingRetryDelay,
                        maxRetryDelay: s.fragLoadingMaxRetryTimeout
                    }, u = {
                        onSuccess: this.loadsuccess.bind(this),
                        onError: this.loaderror.bind(this),
                        onTimeout: this.loadtimeout.bind(this)
                    }, t.loader.load(o, l, u)
                } else this.decryptkey && (a.key = this.decryptkey, this.hls.trigger(d.default.KEY_LOADED, {frag: t}))
            }
        }, {
            key: "loadsuccess", value: function (e, t, r) {
                var i = r.frag;
                this.decryptkey = i.decryptdata.key = new Uint8Array(e.data), i.loader = void 0, this.loaders[i.type] = void 0, this.hls.trigger(d.default.KEY_LOADED, {frag: i})
            }
        }, {
            key: "loaderror", value: function (e, t) {
                var r = t.frag, i = r.loader;
                i && i.abort(), this.loaders[t.type] = void 0, this.hls.trigger(d.default.ERROR, {
                    type: h.ErrorTypes.NETWORK_ERROR,
                    details: h.ErrorDetails.KEY_LOAD_ERROR,
                    fatal: !1,
                    frag: r,
                    response: e
                })
            }
        }, {
            key: "loadtimeout", value: function (e, t) {
                var r = t.frag, i = r.loader;
                i && i.abort(), this.loaders[t.type] = void 0, this.hls.trigger(d.default.ERROR, {
                    type: h.ErrorTypes.NETWORK_ERROR,
                    details: h.ErrorDetails.KEY_LOAD_TIMEOUT,
                    fatal: !1,
                    frag: r
                })
            }
        }]), t
    }(c.default);
    t.default = g
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        if (!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" !== ("undefined" == typeof t ? "undefined" : o(t)) && "function" != typeof t ? e : t
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t)throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : o(t)));
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    Object.defineProperty(t, "__esModule", {value: !0});
    var l = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), u = r(48), d = i(u), f = r(2), c = i(f), h = r(4), v = i(h), g = r(3), p = r(42), y = i(p), m = r(1), E = function (e) {
        function t(e) {
            a(this, t);
            var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, c.default.MANIFEST_LOADING, c.default.LEVEL_LOADING, c.default.AUDIO_TRACK_LOADING));
            return r.loaders = {}, r
        }

        return s(t, e), l(t, [{
            key: "destroy", value: function () {
                for (var e in this.loaders) {
                    var t = this.loaders[e];
                    t && t.destroy()
                }
                this.loaders = {}, v.default.prototype.destroy.call(this)
            }
        }, {
            key: "onManifestLoading", value: function (e) {
                this.load(e.url, {type: "manifest"})
            }
        }, {
            key: "onLevelLoading", value: function (e) {
                this.load(e.url, {type: "level", level: e.level, id: e.id})
            }
        }, {
            key: "onAudioTrackLoading", value: function (e) {
                this.load(e.url, {type: "audioTrack", id: e.id})
            }
        }, {
            key: "load", value: function (e, t) {
                var r = this.loaders[t.type];
                if (r) {
                    var i = r.context;
                    if (i && i.url === e)return void m.logger.trace("playlist request ongoing");
                    m.logger.warn("abort previous loader for type:" + t.type), r.abort()
                }
                var a = this.hls.config, n = void 0, s = void 0, o = void 0, l = void 0;
                "manifest" === t.type ? (n = a.manifestLoadingMaxRetry, s = a.manifestLoadingTimeOut, o = a.manifestLoadingRetryDelay, l = a.manifestLoadingMaxRetryTimeOut) : (n = a.levelLoadingMaxRetry, s = a.levelLoadingTimeOut, o = a.levelLoadingRetryDelay, l = a.levelLoadingMaxRetryTimeOut, m.logger.log("loading playlist for level " + t.level)), r = this.loaders[t.type] = t.loader = "undefined" != typeof a.pLoader ? new a.pLoader(a) : new a.loader(a), t.url = e, t.responseType = "";
                var u = void 0, d = void 0;
                u = {timeout: s, maxRetry: n, retryDelay: o, maxRetryDelay: l}, d = {
                    onSuccess: this.loadsuccess.bind(this),
                    onError: this.loaderror.bind(this),
                    onTimeout: this.loadtimeout.bind(this)
                }, r.load(t, u, d)
            }
        }, {
            key: "resolve", value: function (e, t) {
                return d.default.buildAbsoluteURL(t, e)
            }
        }, {
            key: "parseMasterPlaylist", value: function (e, t) {
                for (var r = [], i = void 0, a = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g; null != (i = a.exec(e));) {
                    var n = {}, s = n.attrs = new y.default(i[1]);
                    n.url = this.resolve(i[2], t);
                    var o = s.decimalResolution("RESOLUTION");
                    o && (n.width = o.width, n.height = o.height), n.bitrate = s.decimalInteger("AVERAGE-BANDWIDTH") || s.decimalInteger("BANDWIDTH"), n.name = s.NAME;
                    var l = s.CODECS;
                    if (l) {
                        l = l.split(/[ ,]+/);
                        for (var u = 0; u < l.length; u++) {
                            var d = l[u];
                            d.indexOf("avc1") !== -1 ? n.videoCodec = this.avc1toavcoti(d) : n.audioCodec = d
                        }
                    }
                    r.push(n)
                }
                return r
            }
        }, {
            key: "parseMasterPlaylistMedia", value: function (e, t, r) {
                for (var i = void 0, a = [], n = /#EXT-X-MEDIA:(.*)/g; null != (i = n.exec(e));) {
                    var s = {}, o = new y.default(i[1]);
                    o.TYPE === r && (s.groupId = o["GROUP-ID"], s.name = o.NAME, s.type = r, s.default = "YES" === o.DEFAULT, s.autoselect = "YES" === o.AUTOSELECT, s.forced = "YES" === o.FORCED, o.URI && (s.url = this.resolve(o.URI, t)), s.lang = o.LANGUAGE, s.name || (s.name = s.lang), a.push(s))
                }
                return a
            }
        }, {
            key: "createInitializationVector", value: function (e) {
                for (var t = new Uint8Array(16), r = 12; r < 16; r++)t[r] = e >> 8 * (15 - r) & 255;
                return t
            }
        }, {
            key: "fragmentDecryptdataFromLevelkey", value: function (e, t) {
                var r = e;
                return e && e.method && e.uri && !e.iv && (r = this.cloneObj(e), r.iv = this.createInitializationVector(t)), r
            }
        }, {
            key: "avc1toavcoti", value: function (e) {
                var t, r = e.split(".");
                return r.length > 2 ? (t = r.shift() + ".", t += parseInt(r.shift()).toString(16), t += ("000" + parseInt(r.shift()).toString(16)).substr(-4)) : t = e, t
            }
        }, {
            key: "cloneObj", value: function (e) {
                return JSON.parse(JSON.stringify(e))
            }
        }, {
            key: "parseLevelPlaylist", value: function (e, t, r, i) {
                var a, n, s, o = 0, l = 0, u = {
                    type: null,
                    version: null,
                    url: t,
                    fragments: [],
                    live: !0,
                    startSN: 0
                }, d = {
                    method: null,
                    key: null,
                    iv: null,
                    uri: null
                }, f = 0, c = null, h = null, v = null, g = null, p = null, E = null, b = [];
                for (s = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT(INF): *(\d+(?:\.\d+)?)(?:,(.*))?)|(?:(?!#)()(\S.+))|(?:#EXT-X-(BYTERANGE): *(\d+(?:@\d+(?:\.\d+)?)?)|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(PROGRAM-DATE-TIME):(.+))|(?:#EXT-X-(VERSION):(\d+))|(?:(#)(.*):(.*))|(?:(#)(.*)))(?:.*)\r?\n?/g; null !== (n = s.exec(e));)switch (n.shift(), n = n.filter(function (e) {
                    return void 0 !== e
                }), n[0]) {
                    case"PLAYLIST-TYPE":
                        u.type = n[1].toUpperCase();
                        break;
                    case"MEDIA-SEQUENCE":
                        o = u.startSN = parseInt(n[1]);
                        break;
                    case"TARGETDURATION":
                        u.targetduration = parseFloat(n[1]);
                        break;
                    case"VERSION":
                        u.version = parseInt(n[1]);
                        break;
                    case"EXTM3U":
                        break;
                    case"ENDLIST":
                        u.live = !1;
                        break;
                    case"DIS":
                        f++, b.push(n);
                        break;
                    case"DISCONTINUITY-SEQ":
                        f = parseInt(n[1]);
                        break;
                    case"BYTERANGE":
                        var k = n[1].split("@");
                        E = 1 === k.length ? p : parseInt(k[1]), p = parseInt(k[0]) + E;
                        break;
                    case"INF":
                        v = parseFloat(n[1]), g = n[2] ? n[2] : null, b.push(n);
                        break;
                    case"":
                        if (!isNaN(v)) {
                            var R = o++;
                            a = this.fragmentDecryptdataFromLevelkey(d, R);
                            var _ = n[1] ? this.resolve(n[1], t) : null;
                            h = {
                                url: _,
                                type: i,
                                duration: v,
                                title: g,
                                start: l,
                                sn: R,
                                level: r,
                                cc: f,
                                decryptdata: a,
                                programDateTime: c,
                                tagList: b
                            }, null !== E && (h.byteRangeStartOffset = E, h.byteRangeEndOffset = p), u.fragments.push(h), l += v, v = null, g = null, E = null, c = null, b = []
                        }
                        break;
                    case"KEY":
                        var S = n[1], T = new y.default(S), A = T.enumeratedString("METHOD"), L = T.URI, w = T.hexadecimalInteger("IV");
                        A && (d = {
                            method: null,
                            key: null,
                            iv: null,
                            uri: null
                        }, L && "AES-128" === A && (d.method = A, d.uri = this.resolve(L, t), d.key = null, d.iv = w));
                        break;
                    case"START":
                        var D = n[1], O = new y.default(D), P = O.decimalFloatingPoint("TIME-OFFSET");
                        isNaN(P) || (u.startTimeOffset = P);
                        break;
                    case"PROGRAM-DATE-TIME":
                        c = new Date(Date.parse(n[1])), b.push(n);
                        break;
                    case"#":
                        n.shift(), b.push(n);
                        break;
                    default:
                        m.logger.warn("line parsed but not handled: " + n)
                }
                return h && !h.url && (u.fragments.pop(), l -= h.duration), u.totalduration = l, u.averagetargetduration = l / u.fragments.length, u.endSN = o - 1, u
            }
        }, {
            key: "loadsuccess", value: function (e, t, r) {
                var i = e.data, a = e.url, n = r.type, s = r.id, o = r.level, l = this.hls;
                if (this.loaders[n] = void 0, void 0 !== a && 0 !== a.indexOf("data:") || (a = r.url), t.tload = performance.now(), 0 === i.indexOf("#EXTM3U"))if (i.indexOf("#EXTINF:") > 0) {
                    var u = "audioTrack" !== n, d = this.parseLevelPlaylist(i, a, (u ? o : s) || 0, u ? "main" : "audio");
                    "manifest" === n && l.trigger(c.default.MANIFEST_LOADED, {
                        levels: [{url: a, details: d}],
                        audioTracks: [],
                        url: a,
                        stats: t
                    }), t.tparsed = performance.now(), d.targetduration ? u ? l.trigger(c.default.LEVEL_LOADED, {
                        details: d,
                        level: o || 0,
                        id: s || 0,
                        stats: t
                    }) : l.trigger(c.default.AUDIO_TRACK_LOADED, {
                        details: d,
                        id: s,
                        stats: t
                    }) : l.trigger(c.default.ERROR, {
                        type: g.ErrorTypes.NETWORK_ERROR,
                        details: g.ErrorDetails.MANIFEST_PARSING_ERROR,
                        fatal: !0,
                        url: a,
                        reason: "invalid targetduration"
                    })
                } else {
                    var f = this.parseMasterPlaylist(i, a);
                    if (f.length) {
                        var h = this.parseMasterPlaylistMedia(i, a, "AUDIO");
                        if (h.length) {
                            var v = !1;
                            h.forEach(function (e) {
                                e.url || (v = !0)
                            }), v === !1 && f[0].audioCodec && !f[0].attrs.AUDIO && (m.logger.log("audio codec signaled in quality level, but no embedded audio track signaled, create one"), h.unshift({
                                type: "main",
                                name: "main"
                            }))
                        }
                        l.trigger(c.default.MANIFEST_LOADED, {levels: f, audioTracks: h, url: a, stats: t})
                    } else l.trigger(c.default.ERROR, {
                        type: g.ErrorTypes.NETWORK_ERROR,
                        details: g.ErrorDetails.MANIFEST_PARSING_ERROR,
                        fatal: !0,
                        url: a,
                        reason: "no level found in manifest"
                    })
                } else l.trigger(c.default.ERROR, {
                    type: g.ErrorTypes.NETWORK_ERROR,
                    details: g.ErrorDetails.MANIFEST_PARSING_ERROR,
                    fatal: !0,
                    url: a,
                    reason: "no EXTM3U delimiter"
                })
            }
        }, {
            key: "loaderror", value: function (e, t) {
                var r, i, a = t.loader;
                switch (t.type) {
                    case"manifest":
                        r = g.ErrorDetails.MANIFEST_LOAD_ERROR, i = !0;
                        break;
                    case"level":
                        r = g.ErrorDetails.LEVEL_LOAD_ERROR, i = !1;
                        break;
                    case"audioTrack":
                        r = g.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, i = !1
                }
                a && (a.abort(), this.loaders[t.type] = void 0), this.hls.trigger(c.default.ERROR, {
                    type: g.ErrorTypes.NETWORK_ERROR,
                    details: r,
                    fatal: i,
                    url: a.url,
                    loader: a,
                    response: e,
                    context: t
                })
            }
        }, {
            key: "loadtimeout", value: function (e, t) {
                var r, i, a = t.loader;
                switch (t.type) {
                    case"manifest":
                        r = g.ErrorDetails.MANIFEST_LOAD_TIMEOUT, i = !0;
                        break;
                    case"level":
                        r = g.ErrorDetails.LEVEL_LOAD_TIMEOUT, i = !1;
                        break;
                    case"audioTrack":
                        r = g.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT, i = !1
                }
                a && (a.abort(), this.loaders[t.type] = void 0), this.hls.trigger(c.default.ERROR, {
                    type: g.ErrorTypes.NETWORK_ERROR,
                    details: r,
                    fatal: i,
                    url: a.url,
                    loader: a,
                    context: t
                })
            }
        }]), t
    }(v.default);
    t.default = E
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e() {
            r(this, e)
        }

        return i(e, null, [{
            key: "init", value: function () {
                e.types = {
                    avc1: [],
                    avcC: [],
                    btrt: [],
                    dinf: [],
                    dref: [],
                    esds: [],
                    ftyp: [],
                    hdlr: [],
                    mdat: [],
                    mdhd: [],
                    mdia: [],
                    mfhd: [],
                    minf: [],
                    moof: [],
                    moov: [],
                    mp4a: [],
                    mvex: [],
                    mvhd: [],
                    sdtp: [],
                    stbl: [],
                    stco: [],
                    stsc: [],
                    stsd: [],
                    stsz: [],
                    stts: [],
                    tfdt: [],
                    tfhd: [],
                    traf: [],
                    trak: [],
                    trun: [],
                    trex: [],
                    tkhd: [],
                    vmhd: [],
                    smhd: []
                };
                var t;
                for (t in e.types)e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
                var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                e.HDLR_TYPES = {video: r, audio: i};
                var a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                e.STTS = e.STSC = e.STCO = n, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                var s = new Uint8Array([105, 115, 111, 109]), o = new Uint8Array([97, 118, 99, 49]), l = new Uint8Array([0, 0, 0, 1]);
                e.FTYP = e.box(e.types.ftyp, s, l, s, o), e.DINF = e.box(e.types.dinf, e.box(e.types.dref, a))
            }
        }, {
            key: "box", value: function (e) {
                for (var t, r = Array.prototype.slice.call(arguments, 1), i = 8, a = r.length, n = a; a--;)i += r[a].byteLength;
                for (t = new Uint8Array(i), t[0] = i >> 24 & 255, t[1] = i >> 16 & 255, t[2] = i >> 8 & 255, t[3] = 255 & i, t.set(e, 4), a = 0, i = 8; a < n; a++)t.set(r[a], i), i += r[a].byteLength;
                return t
            }
        }, {
            key: "hdlr", value: function (t) {
                return e.box(e.types.hdlr, e.HDLR_TYPES[t])
            }
        }, {
            key: "mdat", value: function (t) {
                return e.box(e.types.mdat, t)
            }
        }, {
            key: "mdhd", value: function (t, r) {
                return r *= t, e.box(e.types.mdhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0]))
            }
        }, {
            key: "mdia", value: function (t) {
                return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t))
            }
        }, {
            key: "mfhd", value: function (t) {
                return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]))
            }
        }, {
            key: "minf", value: function (t) {
                return "audio" === t.type ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t))
            }
        }, {
            key: "moof", value: function (t, r, i) {
                return e.box(e.types.moof, e.mfhd(t), e.traf(i, r))
            }
        }, {
            key: "moov", value: function (t) {
                for (var r = t.length, i = []; r--;)i[r] = e.trak(t[r]);
                return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(i).concat(e.mvex(t)))
            }
        }, {
            key: "mvex", value: function (t) {
                for (var r = t.length, i = []; r--;)i[r] = e.trex(t[r]);
                return e.box.apply(null, [e.types.mvex].concat(i))
            }
        }, {
            key: "mvhd", value: function (t, r) {
                r *= t;
                var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                return e.box(e.types.mvhd, i)
            }
        }, {
            key: "sdtp", value: function (t) {
                var r, i, a = t.samples || [], n = new Uint8Array(4 + a.length);
                for (i = 0; i < a.length; i++)r = a[i].flags, n[i + 4] = r.dependsOn << 4 | r.isDependedOn << 2 | r.hasRedundancy;
                return e.box(e.types.sdtp, n)
            }
        }, {
            key: "stbl", value: function (t) {
                return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO))
            }
        }, {
            key: "avc1", value: function (t) {
                var r, i, a, n = [], s = [];
                for (r = 0; r < t.sps.length; r++)i = t.sps[r], a = i.byteLength, n.push(a >>> 8 & 255), n.push(255 & a), n = n.concat(Array.prototype.slice.call(i));
                for (r = 0; r < t.pps.length; r++)i = t.pps[r], a = i.byteLength, s.push(a >>> 8 & 255), s.push(255 & a), s = s.concat(Array.prototype.slice.call(i));
                var o = e.box(e.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | t.sps.length].concat(n).concat([t.pps.length]).concat(s))), l = t.width, u = t.height;
                return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])))
            }
        }, {
            key: "esds", value: function (e) {
                var t = e.config.length;
                return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
            }
        }, {
            key: "mp4a", value: function (t) {
                var r = t.audiosamplerate;
                return e.box(e.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), e.box(e.types.esds, e.esds(t)))
            }
        }, {
            key: "stsd", value: function (t) {
                return "audio" === t.type ? e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t))
            }
        }, {
            key: "tkhd", value: function (t) {
                var r = t.id, i = t.duration * t.timescale, a = t.width, n = t.height;
                return e.box(e.types.tkhd, new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a >> 8 & 255, 255 & a, 0, 0, n >> 8 & 255, 255 & n, 0, 0]))
            }
        }, {
            key: "traf", value: function (t, r) {
                var i = e.sdtp(t), a = t.id;
                return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), e.box(e.types.tfdt, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), e.trun(t, i.length + 16 + 16 + 8 + 16 + 8 + 8), i)
            }
        }, {
            key: "trak", value: function (t) {
                return t.duration = t.duration || 4294967295, e.box(e.types.trak, e.tkhd(t), e.mdia(t))
            }
        }, {
            key: "trex", value: function (t) {
                var r = t.id;
                return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
            }
        }, {
            key: "trun", value: function (t, r) {
                var i, a, n, s, o, l, u = t.samples || [], d = u.length, f = 12 + 16 * d, c = new Uint8Array(f);
                for (r += 8 + f, c.set([0, 0, 15, 1, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), i = 0; i < d; i++)a = u[i], n = a.duration, s = a.size, o = a.flags, l = a.cts, c.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i);
                return e.box(e.types.trun, c)
            }
        }, {
            key: "initSegment", value: function (t) {
                e.types || e.init();
                var r, i = e.moov(t);
                return r = new Uint8Array(e.FTYP.byteLength + i.byteLength), r.set(e.FTYP), r.set(i, e.FTYP.byteLength), r
            }
        }]), e
    }();
    t.default = a
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(33), o = i(s), l = r(2), u = i(l), d = r(1), f = r(39), c = i(f), h = r(3);
    r(46);
    var v = function () {
        function e(t, r, i) {
            a(this, e), this.observer = t, this.id = r, this.config = i, this.ISGenerated = !1, this.PES2MP4SCALEFACTOR = 4, this.PES_TIMESCALE = 9e4, this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR
        }

        return n(e, [{
            key: "destroy", value: function () {
            }
        }, {
            key: "insertDiscontinuity", value: function () {
                this._initPTS = this._initDTS = void 0
            }
        }, {
            key: "switchLevel", value: function () {
                this.ISGenerated = !1;
            }
        }, {
            key: "remux", value: function (e, t, r, i, a, n, s, o, l) {
                if (this.level = e, this.sn = t, this.ISGenerated || this.generateIS(r, i, s), this.ISGenerated)if (r.samples.length) {
                    var d = this.remuxAudio(r, s, o, l);
                    if (i.samples.length) {
                        var f = void 0;
                        d && (f = d.endPTS - d.startPTS), this.remuxVideo(i, s, o, f)
                    }
                } else {
                    var c = void 0;
                    i.samples.length && (c = this.remuxVideo(i, s, o)), c && r.codec && this.remuxEmptyAudio(r, s, o, c)
                }
                a.samples.length && this.remuxID3(a, s), n.samples.length && this.remuxText(n, s), this.observer.trigger(u.default.FRAG_PARSED, {
                    id: this.id,
                    level: this.level,
                    sn: this.sn
                })
            }
        }, {
            key: "generateIS", value: function (e, t, r) {
                var i, a, n = this.observer, s = e.samples, o = t.samples, l = this.PES_TIMESCALE, f = {}, v = {
                    id: this.id,
                    level: this.level,
                    sn: this.sn,
                    tracks: f,
                    unique: !1
                }, g = void 0 === this._initPTS;
                g && (i = a = 1 / 0), e.config && s.length && (e.timescale = e.audiosamplerate, e.timescale * e.duration > Math.pow(2, 32) && !function () {
                    var t = function e(t, r) {
                        return r ? e(r, t % r) : t
                    };
                    e.timescale = e.audiosamplerate / t(e.audiosamplerate, 1024)
                }(), d.logger.log("audio mp4 timescale :" + e.timescale), f.audio = {
                    container: "audio/mp4",
                    codec: e.codec,
                    initSegment: c.default.initSegment([e]),
                    metadata: {channelCount: e.channelCount}
                }, g && (i = a = s[0].pts - l * r)), t.sps && t.pps && o.length && (t.timescale = this.MP4_TIMESCALE, f.video = {
                    container: "video/mp4",
                    codec: t.codec,
                    initSegment: c.default.initSegment([t]),
                    metadata: {width: t.width, height: t.height}
                }, g && (i = Math.min(i, o[0].pts - l * r), a = Math.min(a, o[0].dts - l * r))), Object.keys(f).length ? (n.trigger(u.default.FRAG_PARSING_INIT_SEGMENT, v), this.ISGenerated = !0, g && (this._initPTS = i, this._initDTS = a)) : n.trigger(u.default.ERROR, {
                    type: h.ErrorTypes.MEDIA_ERROR,
                    id: this.id,
                    details: h.ErrorDetails.FRAG_PARSING_ERROR,
                    fatal: !1,
                    reason: "no audio/video samples found"
                })
            }
        }, {
            key: "remuxVideo", value: function (e, t, r, i) {
                var a, n, s, o, l, f, h, v, g = 8, p = this.PES_TIMESCALE, y = this.PES2MP4SCALEFACTOR, m = e.samples, E = [], b = m.reduce(function (e, t) {
                    return Math.max(Math.min(e, t.pts - t.dts), -18e3)
                }, 0);
                if (b < 0) {
                    d.logger.warn("PTS < DTS detected in video samples, shifting DTS by " + Math.round(b / 90) + " ms to overcome this issue");
                    for (var k = 0; k < m.length; k++)m[k].dts += b
                }
                var R = void 0;
                R = r ? this.nextAvcDts : t * p;
                var _ = m[0];
                l = Math.max(this._PTSNormalize(_.dts - this._initDTS, R), 0), o = Math.max(this._PTSNormalize(_.pts - this._initDTS, R), 0);
                var S = Math.round((l - R) / 90);
                r && S && (S > 1 ? d.logger.log("AVC:" + S + " ms hole between fragments detected,filling it") : S < -1 && d.logger.log("AVC:" + -S + " ms overlapping between fragments detected"), l = R, m[0].dts = l + this._initDTS, o = Math.max(o - S, R), m[0].pts = o + this._initDTS, d.logger.log("Video/PTS/DTS adjusted: " + Math.round(o / 90) + "/" + Math.round(l / 90) + ",delta:" + S + " ms")), f = l, _ = m[m.length - 1], v = Math.max(this._PTSNormalize(_.dts - this._initDTS, R), 0), h = Math.max(this._PTSNormalize(_.pts - this._initDTS, R), 0), h = Math.max(h, v);
                var T = navigator.vendor, A = navigator.userAgent, L = T && T.indexOf("Apple") > -1 && A && !A.match("CriOS");
                L && (a = Math.round((v - l) / (y * (m.length - 1))));
                for (var w = 0; w < m.length; w++) {
                    var D = m[w];
                    L ? D.dts = l + w * y * a : (D.dts = Math.max(this._PTSNormalize(D.dts - this._initDTS, R), l), D.dts = Math.round(D.dts / y) * y), D.pts = Math.max(this._PTSNormalize(D.pts - this._initDTS, R), D.dts), D.pts = Math.round(D.pts / y) * y
                }
                n = new Uint8Array(e.len + 4 * e.nbNalu + 8);
                var O = new DataView(n.buffer);
                O.setUint32(0, n.byteLength), n.set(c.default.types.mdat, 4);
                for (var P = 0; P < m.length; P++) {
                    for (var C = m[P], I = 0, x = void 0; C.units.units.length;) {
                        var M = C.units.units.shift();
                        O.setUint32(g, M.data.byteLength), g += 4, n.set(M.data, g), g += M.data.byteLength, I += 4 + M.data.byteLength
                    }
                    if (L)x = Math.max(0, a * Math.round((C.pts - C.dts) / (y * a))); else {
                        if (P < m.length - 1)a = m[P + 1].dts - C.dts; else {
                            var N = this.config, F = C.dts - m[P > 0 ? P - 1 : P].dts;
                            if (N.stretchShortVideoTrack) {
                                var U = N.maxBufferHole, G = N.maxSeekHole, B = Math.floor(Math.min(U, G) * p), j = (i ? o + i * p : this.nextAacPts) - C.pts;
                                j > B ? (a = j - F, a < 0 && (a = F), d.logger.log("It is approximately " + j / 90 + " ms to the next segment; using duration " + a / 90 + " ms for the last video frame.")) : a = F
                            } else a = F
                        }
                        a /= y, x = Math.round((C.pts - C.dts) / y)
                    }
                    E.push({
                        size: I,
                        duration: a,
                        cts: x,
                        flags: {
                            isLeading: 0,
                            isDependedOn: 0,
                            hasRedundancy: 0,
                            degradPrio: 0,
                            dependsOn: C.key ? 2 : 1,
                            isNonSync: C.key ? 0 : 1
                        }
                    })
                }
                this.nextAvcDts = v + a * y;
                var H = e.dropped;
                if (e.len = 0, e.nbNalu = 0, e.dropped = 0, E.length && navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                    var K = E[0].flags;
                    K.dependsOn = 2, K.isNonSync = 0
                }
                e.samples = E, s = c.default.moof(e.sequenceNumber++, l / y, e), e.samples = [];
                var V = {
                    id: this.id,
                    level: this.level,
                    sn: this.sn,
                    data1: s,
                    data2: n,
                    startPTS: o / p,
                    endPTS: (h + y * a) / p,
                    startDTS: l / p,
                    endDTS: this.nextAvcDts / p,
                    type: "video",
                    nb: E.length,
                    dropped: H
                };
                return this.observer.trigger(u.default.FRAG_PARSING_DATA, V), V
            }
        }, {
            key: "remuxAudio", value: function (e, t, r, i) {
                var a, n, s, l, f, h, v, g, p, y, m, E, b, k, R, _, S = this.PES_TIMESCALE, T = e.timescale, A = S / T, L = 1024 * e.timescale / e.audiosamplerate, w = L * A, D = 8, O = [], P = [];
                if (e.samples.sort(function (e, t) {
                        return e.pts - t.pts
                    }), P = e.samples, _ = this.nextAacPts, r |= P.length && _ && (Math.abs(t - _ / S) < .1 || Math.abs(P[0].pts - _ - this._initDTS) < 20 * w), r || (_ = t * S), i)for (var C = 0, I = _; C < P.length;) {
                    var x = P[C], M = this._PTSNormalize(x.pts - this._initDTS, _), N = M - I;
                    if (N <= -w)d.logger.warn("Dropping 1 audio frame @ " + Math.round(I / 90) / 1e3 + "s due to " + Math.round(Math.abs(N / 90)) + " ms overlap."), P.splice(C, 1), e.len -= x.unit.length; else if (N >= w) {
                        var F = Math.round(N / w);
                        d.logger.warn("Injecting " + F + " audio frame @ " + Math.round(I / 90) / 1e3 + "s due to " + Math.round(N / 90) + " ms gap.");
                        for (var U = 0; U < F; U++)R = I + this._initDTS, R = Math.max(R, this._initDTS), k = o.default.getSilentFrame(e.channelCount), k || (d.logger.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), k = x.unit.slice(0)), P.splice(C, 0, {
                            unit: k,
                            pts: R,
                            dts: R
                        }), e.len += k.length, I += w, C += 1;
                        x.pts = x.dts = I + this._initDTS, I += w, C += 1
                    } else Math.abs(N) > .1 * w, I += w, 0 === C ? x.pts = x.dts = this._initDTS + _ : x.pts = x.dts = P[C - 1].pts + w, C += 1
                }
                for (; P.length;) {
                    if (n = P.shift(), l = n.unit, y = n.pts - this._initDTS, m = n.dts - this._initDTS, void 0 !== p)E = this._PTSNormalize(y, p), b = this._PTSNormalize(m, p), s.duration = Math.round((b - p) / A); else {
                        E = this._PTSNormalize(y, _), b = this._PTSNormalize(m, _);
                        var G = Math.round(1e3 * (E - _) / S), B = 0;
                        if (r && G) {
                            if (G > 0)B = Math.round((E - _) / w), d.logger.log(G + " ms hole between AAC samples detected,filling it"), B > 0 && (k = o.default.getSilentFrame(e.channelCount), k || (k = l.slice(0)), e.len += B * k.length); else if (G < -12) {
                                d.logger.log(-G + " ms overlapping between AAC samples detected, drop frame"), e.len -= l.byteLength;
                                continue
                            }
                            E = b = _
                        }
                        if (v = Math.max(0, E), g = Math.max(0, b), !(e.len > 0))return;
                        f = new Uint8Array(e.len + 8), a = new DataView(f.buffer), a.setUint32(0, f.byteLength), f.set(c.default.types.mdat, 4);
                        for (var j = 0; j < B; j++)R = E - (B - j) * w, k = o.default.getSilentFrame(e.channelCount), k || (d.logger.log("Unable to get silent frame for given audio codec; duplicating this frame instead."), k = l.slice(0)), f.set(k, D), D += k.byteLength, s = {
                            size: k.byteLength,
                            cts: 0,
                            duration: 1024,
                            flags: {isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: 1}
                        }, O.push(s)
                    }
                    f.set(l, D), D += l.byteLength, s = {
                        size: l.byteLength,
                        cts: 0,
                        duration: 0,
                        flags: {isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: 1}
                    }, O.push(s), p = b
                }
                var H = 0, K = O.length;
                if (K >= 2 && (H = O[K - 2].duration, s.duration = H), K) {
                    this.nextAacPts = E + A * H, e.len = 0, e.samples = O, h = c.default.moof(e.sequenceNumber++, g / A, e), e.samples = [];
                    var V = {
                        id: this.id,
                        level: this.level,
                        sn: this.sn,
                        data1: h,
                        data2: f,
                        startPTS: v / S,
                        endPTS: this.nextAacPts / S,
                        startDTS: g / S,
                        endDTS: (b + A * H) / S,
                        type: "audio",
                        nb: K
                    };
                    return this.observer.trigger(u.default.FRAG_PARSING_DATA, V), V
                }
                return null
            }
        }, {
            key: "remuxEmptyAudio", value: function (e, t, r, i) {
                var a = this.PES_TIMESCALE, n = e.timescale ? e.timescale : e.audiosamplerate, s = a / n, l = this.nextAacPts, u = (void 0 !== l ? l : i.startDTS * a) + this._initDTS, f = i.endDTS * a + this._initDTS, c = 1024, h = s * c, v = Math.ceil((f - u) / h), g = o.default.getSilentFrame(e.channelCount);
                if (d.logger.warn("remux empty Audio"), !g)return void d.logger.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!");
                for (var p = [], y = 0; y < v; y++) {
                    var m = u + y * h;
                    p.push({unit: g.slice(0), pts: m, dts: m}), e.len += g.length
                }
                e.samples = p, this.remuxAudio(e, t, r)
            }
        }, {
            key: "remuxID3", value: function (e, t) {
                var r, i = e.samples.length;
                if (i) {
                    for (var a = 0; a < i; a++)r = e.samples[a], r.pts = (r.pts - this._initPTS) / this.PES_TIMESCALE, r.dts = (r.dts - this._initDTS) / this.PES_TIMESCALE;
                    this.observer.trigger(u.default.FRAG_PARSING_METADATA, {
                        id: this.id,
                        level: this.level,
                        sn: this.sn,
                        samples: e.samples
                    })
                }
                e.samples = [], t = t
            }
        }, {
            key: "remuxText", value: function (e, t) {
                e.samples.sort(function (e, t) {
                    return e.pts - t.pts
                });
                var r, i = e.samples.length;
                if (i) {
                    for (var a = 0; a < i; a++)r = e.samples[a], r.pts = (r.pts - this._initPTS) / this.PES_TIMESCALE;
                    this.observer.trigger(u.default.FRAG_PARSING_USERDATA, {
                        id: this.id,
                        level: this.level,
                        sn: this.sn,
                        samples: e.samples
                    })
                }
                e.samples = [], t = t
            }
        }, {
            key: "_PTSNormalize", value: function (e, t) {
                var r;
                if (void 0 === t)return e;
                for (r = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;)e += r;
                return e
            }
        }, {
            key: "passthrough", get: function () {
                return !1
            }
        }]), e
    }();
    t.default = v
}, function (e, t, r) {
    "use strict";
    function i(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), s = r(2), o = i(s), l = function () {
        function e(t, r) {
            a(this, e), this.observer = t, this.id = r, this.ISGenerated = !1
        }

        return n(e, [{
            key: "destroy", value: function () {
            }
        }, {
            key: "insertDiscontinuity", value: function () {
            }
        }, {
            key: "switchLevel", value: function () {
                this.ISGenerated = !1
            }
        }, {
            key: "remux", value: function (e, t, r, i, a, n) {
                var s = this.observer;
                if (!this.ISGenerated) {
                    var l = {}, u = {id: this.id, tracks: l, unique: !0}, d = t, f = d.codec;
                    f && (u.tracks.video = {
                        container: d.container,
                        codec: f,
                        metadata: {width: d.width, height: d.height}
                    }), d = e, f = d.codec, f && (u.tracks.audio = {
                        container: d.container,
                        codec: f,
                        metadata: {channelCount: d.channelCount}
                    }), this.ISGenerated = !0, s.trigger(o.default.FRAG_PARSING_INIT_SEGMENT, u)
                }
                s.trigger(o.default.FRAG_PARSING_DATA, {
                    id: this.id,
                    data1: n,
                    startPTS: a,
                    startDTS: a,
                    type: "audiovideo",
                    nb: 1,
                    dropped: 0
                })
            }
        }, {
            key: "passthrough", get: function () {
                return !0
            }
        }]), e
    }();
    t.default = l
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e(t) {
            r(this, e), "string" == typeof t && (t = e.parseAttrList(t));
            for (var i in t)t.hasOwnProperty(i) && (this[i] = t[i])
        }

        return i(e, [{
            key: "decimalInteger", value: function (e) {
                var t = parseInt(this[e], 10);
                return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
            }
        }, {
            key: "hexadecimalInteger", value: function (e) {
                if (this[e]) {
                    var t = (this[e] || "0x").slice(2);
                    t = (1 & t.length ? "0" : "") + t;
                    for (var r = new Uint8Array(t.length / 2), i = 0; i < t.length / 2; i++)r[i] = parseInt(t.slice(2 * i, 2 * i + 2), 16);
                    return r
                }
                return null
            }
        }, {
            key: "hexadecimalIntegerAsNumber", value: function (e) {
                var t = parseInt(this[e], 16);
                return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
            }
        }, {
            key: "decimalFloatingPoint", value: function (e) {
                return parseFloat(this[e])
            }
        }, {
            key: "enumeratedString", value: function (e) {
                return this[e]
            }
        }, {
            key: "decimalResolution", value: function (e) {
                var t = /^(\d+)x(\d+)$/.exec(this[e]);
                if (null !== t)return {width: parseInt(t[1], 10), height: parseInt(t[2], 10)}
            }
        }], [{
            key: "parseAttrList", value: function (e) {
                for (var t, r = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g, i = {}; null !== (t = r.exec(e));) {
                    var a = t[2], n = '"';
                    0 === a.indexOf(n) && a.lastIndexOf(n) === a.length - 1 && (a = a.slice(1, -1)), i[t[1]] = a
                }
                return i
            }
        }]), e
    }();
    t.default = a
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = {
        42: 225,
        92: 233,
        94: 237,
        95: 243,
        96: 250,
        123: 231,
        124: 247,
        125: 209,
        126: 241,
        127: 9608,
        128: 174,
        129: 176,
        130: 189,
        131: 191,
        132: 8482,
        133: 162,
        134: 163,
        135: 9834,
        136: 224,
        137: 32,
        138: 232,
        139: 226,
        140: 234,
        141: 238,
        142: 244,
        143: 251,
        144: 193,
        145: 201,
        146: 211,
        147: 218,
        148: 220,
        149: 252,
        150: 8216,
        151: 161,
        152: 42,
        153: 8217,
        154: 9473,
        155: 169,
        156: 8480,
        157: 8226,
        158: 8220,
        159: 8221,
        160: 192,
        161: 194,
        162: 199,
        163: 200,
        164: 202,
        165: 203,
        166: 235,
        167: 206,
        168: 207,
        169: 239,
        170: 212,
        171: 217,
        172: 249,
        173: 219,
        174: 171,
        175: 187,
        176: 195,
        177: 227,
        178: 205,
        179: 204,
        180: 236,
        181: 210,
        182: 242,
        183: 213,
        184: 245,
        185: 123,
        186: 125,
        187: 92,
        188: 94,
        189: 95,
        190: 124,
        191: 8764,
        192: 196,
        193: 228,
        194: 214,
        195: 246,
        196: 223,
        197: 165,
        198: 164,
        199: 9475,
        200: 197,
        201: 229,
        202: 216,
        203: 248,
        204: 9487,
        205: 9491,
        206: 9495,
        207: 9499
    }, n = function (e) {
        var t = e;
        return a.hasOwnProperty(e) && (t = a[e]), String.fromCharCode(t)
    }, s = 15, o = 32, l = {17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14}, u = {
        17: 2,
        18: 4,
        21: 6,
        22: 8,
        23: 10,
        19: 13,
        20: 15
    }, d = {25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14}, f = {
        25: 2,
        26: 4,
        29: 6,
        30: 8,
        31: 10,
        27: 13,
        28: 15
    }, c = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"], h = {
        verboseFilter: {
            DATA: 3,
            DEBUG: 3,
            INFO: 2,
            WARNING: 2,
            TEXT: 1,
            ERROR: 0
        }, time: null, verboseLevel: 0, setTime: function (e) {
            this.time = e
        }, log: function (e, t) {
            var r = this.verboseFilter[e];
            this.verboseLevel >= r && console.log(this.time + " [" + e + "] " + t)
        }
    }, v = function (e) {
        for (var t = [], r = 0; r < e.length; r++)t.push(e[r].toString(16));
        return t
    }, g = function () {
        function e(t, i, a, n, s) {
            r(this, e), this.foreground = t || "white", this.underline = i || !1, this.italics = a || !1, this.background = n || "black", this.flash = s || !1
        }

        return i(e, [{
            key: "reset", value: function () {
                this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
            }
        }, {
            key: "setStyles", value: function (e) {
                for (var t = ["foreground", "underline", "italics", "background", "flash"], r = 0; r < t.length; r++) {
                    var i = t[r];
                    e.hasOwnProperty(i) && (this[i] = e[i])
                }
            }
        }, {
            key: "isDefault", value: function () {
                return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
            }
        }, {
            key: "equals", value: function (e) {
                return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
            }
        }, {
            key: "copy", value: function (e) {
                this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash
            }
        }, {
            key: "toString", value: function () {
                return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
            }
        }]), e
    }(), p = function () {
        function e(t, i, a, n, s, o) {
            r(this, e), this.uchar = t || " ", this.penState = new g(i, a, n, s, o)
        }

        return i(e, [{
            key: "reset", value: function () {
                this.uchar = " ", this.penState.reset()
            }
        }, {
            key: "setChar", value: function (e, t) {
                this.uchar = e, this.penState.copy(t)
            }
        }, {
            key: "setPenState", value: function (e) {
                this.penState.copy(e)
            }
        }, {
            key: "equals", value: function (e) {
                return this.uchar === e.uchar && this.penState.equals(e.penState)
            }
        }, {
            key: "copy", value: function (e) {
                this.uchar = e.uchar, this.penState.copy(e.penState)
            }
        }, {
            key: "isEmpty", value: function () {
                return " " === this.uchar && this.penState.isDefault()
            }
        }]), e
    }(), y = function () {
        function e() {
            r(this, e), this.chars = [];
            for (var t = 0; t < o; t++)this.chars.push(new p);
            this.pos = 0, this.currPenState = new g
        }

        return i(e, [{
            key: "equals", value: function (e) {
                for (var t = !0, r = 0; r < o; r++)if (!this.chars[r].equals(e.chars[r])) {
                    t = !1;
                    break
                }
                return t
            }
        }, {
            key: "copy", value: function (e) {
                for (var t = 0; t < o; t++)this.chars[t].copy(e.chars[t])
            }
        }, {
            key: "isEmpty", value: function () {
                for (var e = !0, t = 0; t < o; t++)if (!this.chars[t].isEmpty()) {
                    e = !1;
                    break
                }
                return e
            }
        }, {
            key: "setCursor", value: function (e) {
                this.pos !== e && (this.pos = e), this.pos < 0 ? (h.log("ERROR", "Negative cursor position " + this.pos), this.pos = 0) : this.pos > o && (h.log("ERROR", "Too large cursor position " + this.pos), this.pos = o)
            }
        }, {
            key: "moveCursor", value: function (e) {
                var t = this.pos + e;
                if (e > 1)for (var r = this.pos + 1; r < t + 1; r++)this.chars[r].setPenState(this.currPenState);
                this.setCursor(t)
            }
        }, {
            key: "backSpace", value: function () {
                this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
            }
        }, {
            key: "insertChar", value: function (e) {
                e >= 144 && this.backSpace();
                var t = n(e);
                return this.pos >= o ? void h.log("ERROR", "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!") : (this.chars[this.pos].setChar(t, this.currPenState), void this.moveCursor(1))
            }
        }, {
            key: "clearFromPos", value: function (e) {
                var t;
                for (t = e; t < o; t++)this.chars[t].reset()
            }
        }, {
            key: "clear", value: function () {
                this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
            }
        }, {
            key: "clearToEndOfRow", value: function () {
                this.clearFromPos(this.pos)
            }
        }, {
            key: "getTextString", value: function () {
                for (var e = [], t = !0, r = 0; r < o; r++) {
                    var i = this.chars[r].uchar;
                    " " !== i && (t = !1), e.push(i)
                }
                return t ? "" : e.join("")
            }
        }, {
            key: "setPenStyles", value: function (e) {
                this.currPenState.setStyles(e);
                var t = this.chars[this.pos];
                t.setPenState(this.currPenState)
            }
        }]), e
    }(), m = function () {
        function e() {
            r(this, e), this.rows = [];
            for (var t = 0; t < s; t++)this.rows.push(new y);
            this.currRow = s - 1, this.nrRollUpRows = null, this.reset()
        }

        return i(e, [{
            key: "reset", value: function () {
                for (var e = 0; e < s; e++)this.rows[e].clear();
                this.currRow = s - 1
            }
        }, {
            key: "equals", value: function (e) {
                for (var t = !0, r = 0; r < s; r++)if (!this.rows[r].equals(e.rows[r])) {
                    t = !1;
                    break
                }
                return t
            }
        }, {
            key: "copy", value: function (e) {
                for (var t = 0; t < s; t++)this.rows[t].copy(e.rows[t])
            }
        }, {
            key: "isEmpty", value: function () {
                for (var e = !0, t = 0; t < s; t++)if (!this.rows[t].isEmpty()) {
                    e = !1;
                    break
                }
                return e
            }
        }, {
            key: "backSpace", value: function () {
                var e = this.rows[this.currRow];
                e.backSpace()
            }
        }, {
            key: "clearToEndOfRow", value: function () {
                var e = this.rows[this.currRow];
                e.clearToEndOfRow()
            }
        }, {
            key: "insertChar", value: function (e) {
                var t = this.rows[this.currRow];
                t.insertChar(e)
            }
        }, {
            key: "setPen", value: function (e) {
                var t = this.rows[this.currRow];
                t.setPenStyles(e)
            }
        }, {
            key: "moveCursor", value: function (e) {
                var t = this.rows[this.currRow];
                t.moveCursor(e)
            }
        }, {
            key: "setCursor", value: function (e) {
                h.log("INFO", "setCursor: " + e);
                var t = this.rows[this.currRow];
                t.setCursor(e)
            }
        }, {
            key: "setPAC", value: function (e, t) {
                h.log("INFO", "pacData = " + JSON.stringify(e));
                var r = e.row - 1;
                if (this.nrRollUpRows && r < this.nrRollUpRows - 1 && (r = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== r) {
                    for (var i = 0; i < s; i++)this.rows[i].clear();
                    var a = this.currRow + 1 - this.nrRollUpRows, n = t.rows[a].cueStartTime;
                    if (n && n < h.time)for (i = 0; i < this.nrRollUpRows; i++)this.rows[r - this.nrRollUpRows + i + 1].copy(t.rows[a + i])
                }
                this.currRow = r;
                var o = this.rows[this.currRow];
                if (null !== e.indent) {
                    var l = e.indent, u = Math.max(l - 1, 0);
                    o.setCursor(e.indent), e.color = o.chars[u].penState.foreground
                }
                var d = {
                    foreground: e.color,
                    underline: e.underline,
                    italics: e.italics,
                    background: "black",
                    flash: !1
                };
                this.setPen(d)
            }
        }, {
            key: "setBkgData", value: function (e) {
                h.log("INFO", "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32)
            }
        }, {
            key: "setRollUpRows", value: function (e) {
                this.nrRollUpRows = e
            }
        }, {
            key: "rollUp", value: function () {
                if (null === this.nrRollUpRows)return void h.log("DEBUG", "roll_up but nrRollUpRows not set yet");
                h.log("TEXT", this.getDisplayText());
                var e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0];
                t.clear(), this.rows.splice(this.currRow, 0, t), h.log("INFO", "Rolling up")
            }
        }, {
            key: "getDisplayText", value: function (e) {
                e = e || !1;
                for (var t = [], r = "", i = -1, a = 0; a < s; a++) {
                    var n = this.rows[a].getTextString();
                    n && (i = a + 1, e ? t.push("Row " + i + ": '" + n + "'") : t.push(n.trim()))
                }
                return t.length > 0 && (r = e ? "[" + t.join(" | ") + "]" : t.join("\n")), r
            }
        }, {
            key: "getTextAndFormat", value: function () {
                return this.rows
            }
        }]), e
    }(), E = function () {
        function e(t, i) {
            r(this, e), this.chNr = t, this.outputFilter = i, this.mode = null, this.verbose = 0, this.displayedMemory = new m, this.nonDisplayedMemory = new m, this.lastOutputScreen = new m, this.currRollUpRow = this.displayedMemory.rows[s - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
        }

        return i(e, [{
            key: "reset", value: function () {
                this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[s - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.lastCueEndTime = null
            }
        }, {
            key: "getHandler", value: function () {
                return this.outputFilter
            }
        }, {
            key: "setHandler", value: function (e) {
                this.outputFilter = e
            }
        }, {
            key: "setPAC", value: function (e) {
                this.writeScreen.setPAC(e, this.lastOutputScreen)
            }
        }, {
            key: "setBkgData", value: function (e) {
                this.writeScreen.setBkgData(e)
            }
        }, {
            key: "setMode", value: function (e) {
                e !== this.mode && (this.mode = e, h.log("INFO", "MODE=" + e), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset(), this.lastOutputScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e)
            }
        }, {
            key: "insertChars", value: function (e) {
                for (var t = 0; t < e.length; t++)this.writeScreen.insertChar(e[t]);
                var r = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                h.log("INFO", r + ": " + this.writeScreen.getDisplayText(!0)), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (h.log("TEXT", "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate())
            }
        }, {
            key: "ccRCL", value: function () {
                h.log("INFO", "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
            }
        }, {
            key: "ccBS", value: function () {
                h.log("INFO", "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
            }
        }, {
            key: "ccAOF", value: function () {
            }
        }, {
            key: "ccAON", value: function () {
            }
        }, {
            key: "ccDER", value: function () {
                h.log("INFO", "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
            }
        }, {
            key: "ccRU", value: function (e) {
                h.log("INFO", "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e)
            }
        }, {
            key: "ccFON", value: function () {
                h.log("INFO", "FON - Flash On"), this.writeScreen.setPen({flash: !0})
            }
        }, {
            key: "ccRDC", value: function () {
                h.log("INFO", "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
            }
        }, {
            key: "ccTR", value: function () {
                h.log("INFO", "TR"), this.setMode("MODE_TEXT")
            }
        }, {
            key: "ccRTD", value: function () {
                h.log("INFO", "RTD"), this.setMode("MODE_TEXT")
            }
        }, {
            key: "ccEDM", value: function () {
                h.log("INFO", "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate()
            }
        }, {
            key: "ccCR", value: function () {
                h.log("CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate()
            }
        }, {
            key: "ccENM", value: function () {
                h.log("INFO", "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
            }
        }, {
            key: "ccEOC", value: function () {
                if (h.log("INFO", "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
                    var e = this.displayedMemory;
                    this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, h.log("TEXT", "DISP: " + this.displayedMemory.getDisplayText())
                }
                this.outputDataUpdate()
            }
        }, {
            key: "ccTO", value: function (e) {
                h.log("INFO", "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e)
            }
        }, {
            key: "ccMIDROW", value: function (e) {
                var t = {flash: !1};
                if (t.underline = e % 2 === 1, t.italics = e >= 46, t.italics)t.foreground = "white"; else {
                    var r = Math.floor(e / 2) - 16, i = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                    t.foreground = i[r]
                }
                h.log("INFO", "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t)
            }
        }, {
            key: "outputDataUpdate", value: function () {
                var e = h.time;
                null !== e && this.outputFilter && (this.outputFilter.updateData && this.outputFilter.updateData(e, this.displayedMemory), null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.lastOutputScreen), this.cueStartTime = this.displayedMemory.isEmpty() ? null : e) : this.cueStartTime = e, this.lastOutputScreen.copy(this.displayedMemory))
            }
        }, {
            key: "cueSplitAtTime", value: function (e) {
                this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e))
            }
        }]), e
    }(), b = function () {
        function e(t, i, a) {
            r(this, e), this.field = t || 1, this.outputs = [i, a], this.channels = [new E(1, i), new E(2, a)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.bufferedData = [], this.startTime = null, this.lastTime = null, this.dataCounters = {
                padding: 0,
                char: 0,
                cmd: 0,
                other: 0
            }
        }

        return i(e, [{
            key: "getHandler", value: function (e) {
                return this.channels[e].getHandler()
            }
        }, {
            key: "setHandler", value: function (e, t) {
                this.channels[e].setHandler(t)
            }
        }, {
            key: "addData", value: function (e, t) {
                var r, i, a, n = !1;
                this.lastTime = e, h.setTime(e);
                for (var s = 0; s < t.length; s += 2)if (i = 127 & t[s], a = 127 & t[s + 1], 0 !== i || 0 !== a) {
                    if (h.log("DATA", "[" + v([t[s], t[s + 1]]) + "] -> (" + v([i, a]) + ")"), r = this.parseCmd(i, a), r || (r = this.parseMidrow(i, a)), r || (r = this.parsePAC(i, a)), r || (r = this.parseBackgroundAttributes(i, a)), !r && (n = this.parseChars(i, a)))if (this.currChNr && this.currChNr >= 0) {
                        var o = this.channels[this.currChNr - 1];
                        o.insertChars(n)
                    } else h.log("WARNING", "No channel found yet. TEXT-MODE?");
                    r ? this.dataCounters.cmd += 2 : n ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, h.log("WARNING", "Couldn't parse cleaned data " + v([i, a]) + " orig: " + v([t[s], t[s + 1]])))
                } else this.dataCounters.padding += 2
            }
        }, {
            key: "parseCmd", value: function (e, t) {
                var r = null, i = (20 === e || 28 === e) && 32 <= t && t <= 47, a = (23 === e || 31 === e) && 33 <= t && t <= 35;
                if (!i && !a)return !1;
                if (e === this.lastCmdA && t === this.lastCmdB)return this.lastCmdA = null, this.lastCmdB = null, h.log("DEBUG", "Repeated command (" + v([e, t]) + ") is dropped"), !0;
                r = 20 === e || 23 === e ? 1 : 2;
                var n = this.channels[r - 1];
                return 20 === e || 28 === e ? 32 === t ? n.ccRCL() : 33 === t ? n.ccBS() : 34 === t ? n.ccAOF() : 35 === t ? n.ccAON() : 36 === t ? n.ccDER() : 37 === t ? n.ccRU(2) : 38 === t ? n.ccRU(3) : 39 === t ? n.ccRU(4) : 40 === t ? n.ccFON() : 41 === t ? n.ccRDC() : 42 === t ? n.ccTR() : 43 === t ? n.ccRTD() : 44 === t ? n.ccEDM() : 45 === t ? n.ccCR() : 46 === t ? n.ccENM() : 47 === t && n.ccEOC() : n.ccTO(t - 32), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0
            }
        }, {
            key: "parseMidrow", value: function (e, t) {
                var r = null;
                if ((17 === e || 25 === e) && 32 <= t && t <= 47) {
                    if (r = 17 === e ? 1 : 2, r !== this.currChNr)return h.log("ERROR", "Mismatch channel in midrow parsing"), !1;
                    var i = this.channels[r - 1];
                    return i.ccMIDROW(t), h.log("DEBUG", "MIDROW (" + v([e, t]) + ")"), !0
                }
                return !1
            }
        }, {
            key: "parsePAC", value: function (e, t) {
                var r = null, i = null, a = (17 <= e && e <= 23 || 25 <= e && e <= 31) && 64 <= t && t <= 127, n = (16 === e || 24 === e) && 64 <= t && t <= 95;
                if (!a && !n)return !1;
                if (e === this.lastCmdA && t === this.lastCmdB)return this.lastCmdA = null, this.lastCmdB = null, !0;
                r = e <= 23 ? 1 : 2, i = 64 <= t && t <= 95 ? 1 === r ? l[e] : d[e] : 1 === r ? u[e] : f[e];
                var s = this.interpretPAC(i, t), o = this.channels[r - 1];
                return o.setPAC(s), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0
            }
        }, {
            key: "interpretPAC", value: function (e, t) {
                var r = t, i = {color: null, italics: !1, indent: null, underline: !1, row: e};
                return r = t > 95 ? t - 96 : t - 64, i.underline = 1 === (1 & r), r <= 13 ? i.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (i.italics = !0, i.color = "white") : i.indent = 4 * Math.floor((r - 16) / 2), i
            }
        }, {
            key: "parseChars", value: function (e, t) {
                var r = null, i = null, a = null;
                if (e >= 25 ? (r = 2, a = e - 8) : (r = 1, a = e), 17 <= a && a <= 19) {
                    var s = t;
                    s = 17 === a ? t + 80 : 18 === a ? t + 112 : t + 144, h.log("INFO", "Special char '" + n(s) + "' in channel " + r), i = [s]
                } else 32 <= e && e <= 127 && (i = 0 === t ? [e] : [e, t]);
                if (i) {
                    var o = v(i);
                    h.log("DEBUG", "Char codes =  " + o.join(",")), this.lastCmdA = null, this.lastCmdB = null
                }
                return i
            }
        }, {
            key: "parseBackgroundAttributes", value: function (e, t) {
                var r, i, a, n, s = (16 === e || 24 === e) && 32 <= t && t <= 47, o = (23 === e || 31 === e) && 45 <= t && t <= 47;
                return !(!s && !o) && (r = {}, 16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), r.background = c[i], t % 2 === 1 && (r.background = r.background + "_semi")) : 45 === t ? r.background = "transparent" : (r.foreground = "black", 47 === t && (r.underline = !0)), a = e < 24 ? 1 : 2, n = this.channels[a - 1], n.setBkgData(r), this.lastCmdA = null, this.lastCmdB = null, !0)
            }
        }, {
            key: "reset", value: function () {
                for (var e = 0; e < this.channels.length; e++)this.channels[e] && this.channels[e].reset();
                this.lastCmdA = null, this.lastCmdB = null
            }
        }, {
            key: "cueSplitAtTime", value: function (e) {
                for (var t = 0; t < this.channels.length; t++)this.channels[t] && this.channels[t].cueSplitAtTime(e)
            }
        }]), e
    }();
    t.default = b
}, function (e, t) {
    "use strict";
    var r = {
        newCue: function (e, t, r, i) {
            for (var a, n, s, o, l, u = window.VTTCue || window.TextTrackCue, d = 0; d < i.rows.length; d++)if (a = i.rows[d], s = !0, o = 0, l = "", !a.isEmpty()) {
                for (var f = 0; f < a.chars.length; f++)a.chars[f].uchar.match(/\s/) && s ? o++ : (l += a.chars[f].uchar, s = !1);
                a.cueStartTime = t, n = new u(t, r, l.trim()), o >= 16 ? o-- : o++, navigator.userAgent.match(/Firefox\//) ? n.line = d + 1 : n.line = d > 7 ? d - 2 : d + 1, n.align = "left", n.position = Math.max(0, Math.min(100, 100 * (o / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0))), e.addCue(n)
            }
        }
    };
    e.exports = r
}, function (e, t) {
    "use strict";
    function r(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), a = function () {
        function e(t) {
            r(this, e), this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = 0, this.totalWeight_ = 0
        }

        return i(e, [{
            key: "sample", value: function (e, t) {
                var r = Math.pow(this.alpha_, e);
                this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e
            }
        }, {
            key: "getTotalWeight", value: function () {
                return this.totalWeight_
            }
        }, {
            key: "getEstimate", value: function () {
                if (this.alpha_) {
                    var e = 1 - Math.pow(this.alpha_, this.totalWeight_);
                    return this.estimate_ / e
                }
                return this.estimate_
            }
        }]), e
    }();
    t.default = a
}, function (e, t) {
    "use strict";
    "undefined" == typeof ArrayBuffer || ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function (e, t) {
        var r = new Uint8Array(this);
        void 0 === t && (t = r.length);
        for (var i = new ArrayBuffer(t - e), a = new Uint8Array(i), n = 0; n < a.length; n++)a[n] = r[n + e];
        return i
    })
}, function (e, t, r) {
    "use strict";
    function i(e, t) {
        if (!(e instanceof t))throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(t, "__esModule", {value: !0});
    var a = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), n = r(1), s = function () {
        function e(t) {
            i(this, e), t && t.xhrSetup && (this.xhrSetup = t.xhrSetup)
        }

        return a(e, [{
            key: "destroy", value: function () {
                this.abort(), this.loader = null
            }
        }, {
            key: "abort", value: function () {
                var e = this.loader;
                e && 4 !== e.readyState && (this.stats.aborted = !0, e.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null
            }
        }, {
            key: "load", value: function (e, t, r) {
                this.context = e, this.config = t, this.callbacks = r, this.stats = {
                    trequest: performance.now(),
                    retry: 0
                }, this.retryDelay = t.retryDelay, this.loadInternal()
            }
        }, {
            key: "loadInternal", value: function () {
                var e, t = this.context;
                e = "undefined" != typeof XDomainRequest ? this.loader = new XDomainRequest : this.loader = new XMLHttpRequest, e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.open("GET", t.url, !0), t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.responseType = t.responseType;
                var r = this.stats;
                r.tfirst = 0, r.loaded = 0, this.xhrSetup && this.xhrSetup(e, t.url), this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), e.send()
            }
        }, {
            key: "readystatechange", value: function (e) {
                var t = e.currentTarget, r = t.readyState, i = this.stats, a = this.context, s = this.config;
                if (!i.aborted && (window.clearTimeout(this.requestTimeout), r >= 2 && (0 === i.tfirst && (i.tfirst = Math.max(performance.now(), i.trequest), this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), s.timeout - (i.tfirst - i.trequest))), 4 === r))) {
                    var o = t.status;
                    if (o >= 200 && o < 300) {
                        i.tload = Math.max(i.tfirst, performance.now());
                        var l = void 0, u = void 0;
                        "arraybuffer" === a.responseType ? (l = t.response, u = l.byteLength) : (l = t.responseText, u = l.length), i.loaded = i.total = u;
                        var d = {url: t.responseURL, data: l};
                        this.callbacks.onSuccess(d, i, a)
                    } else i.retry >= s.maxRetry || o >= 400 && o < 499 ? (n.logger.error(o + " while loading " + a.url), this.callbacks.onError({
                        code: o,
                        text: t.statusText
                    }, a)) : (n.logger.warn(o + " while loading " + a.url + ", retrying in " + this.retryDelay + "..."), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay),
                        this.retryDelay = Math.min(2 * this.retryDelay, s.maxRetryDelay), i.retry++)
                }
            }
        }, {
            key: "loadtimeout", value: function () {
                n.logger.warn("timeout while loading " + this.context.url), this.callbacks.onTimeout(this.stats, this.context)
            }
        }, {
            key: "loadprogress", value: function (e) {
                var t = this.stats;
                t.loaded = e.loaded, e.lengthComputable && (t.total = e.total);
                var r = this.callbacks.onProgress;
                r && r(t, this.context, null)
            }
        }]), e
    }();
    t.default = s
}, function (e, t, r) {
    var i, a;
    (function (e) {
        "use strict";
        var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e
        } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        };
        !function (n) {
            var s = {
                buildAbsoluteURL: function (e, t) {
                    if (t = t.trim(), /^[a-z]+:/i.test(t))return t;
                    var r = null, i = null, a = /^([^#]*)(.*)$/.exec(t);
                    a && (i = a[2], t = a[1]);
                    var n = /^([^\?]*)(.*)$/.exec(t);
                    n && (r = n[2], t = n[1]);
                    var o = /^([^#]*)(.*)$/.exec(e);
                    o && (e = o[1]);
                    var l = /^([^\?]*)(.*)$/.exec(e);
                    l && (e = l[1]);
                    var u = /^(([a-z]+:)?\/\/[a-z0-9\.\-_~]+(:[0-9]+)?)?(\/.*)$/i.exec(e);
                    if (!u)throw new Error("Error trying to parse base URL.");
                    var d = u[2] || "", f = u[1] || "", c = u[4], h = null;
                    return h = /^\/\//.test(t) ? d + "//" + s.buildAbsolutePath("", t.substring(2)) : /^\//.test(t) ? f + "/" + s.buildAbsolutePath("", t.substring(1)) : s.buildAbsolutePath(f + c, t), r && (h += r), i && (h += i), h
                }, buildAbsolutePath: function (e, t) {
                    for (var r, i, a = t, n = "", s = e.replace(/[^\/]*$/, a.replace(/(\/|^)(?:\.?\/+)+/g, "$1")), o = 0; i = s.indexOf("/../", o), i > -1; o = i + r)r = /^\/(?:\.\.\/)*/.exec(s.slice(i))[0].length, n = (n + s.substring(o, i)).replace(new RegExp("(?:\\/+[^\\/]*){0," + (r - 1) / 3 + "}$"), "/");
                    return n + s.substr(o)
                }
            };
            "object" === r(t) && "object" === r(e) ? e.exports = s : (i = [], a = function () {
                return s
            }.apply(t, i), !(void 0 !== a && (e.exports = a)))
        }(void 0)
    }).call(t, r(49)(e))
}, function (e, t) {
    e.exports = function (e) {
        return e.webpackPolyfill || (e.deprecate = function () {
        }, e.paths = [], e.children = [], e.webpackPolyfill = 1), e
    }
}, function (e, t) {
    function r(e) {
        return (e + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
    }

    var i = arguments[2], a = i.m, n = i.s || "0", s = arguments[0].id || arguments[0].i, o = function (e) {
        function t(i) {
            if (r[i])return r[i].exports;
            var a = r[i] = {exports: {}, id: i, loaded: !1};
            return e[i].call(a.exports, a, a.exports, t), a.loaded = !0, a.exports
        }

        var r = {};
        t.m = e, t.c = r, t.oe = function (e) {
            throw e
        }, t.p = "";
        var i = t(t.s = entryModule);
        return i.default || i
    };
    e.exports = function (e, t) {
        for (var l, u = [], d = [n], f = Object.keys(a), c = 0, h = f.length; c < h; c++) {
            var v = f[c];
            if (a[v]) {
                var g = a[v].toString();
                u[v] = g;
                var p = g.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
                if (p) {
                    var y = p[1];
                    if (g.indexOf(y + "(" + s + ")") > -1)for (var m, E = new RegExp(r(y) + "\\((\\d+)\\)", "g"); m = E.exec(g);)m[1] != "" + s && d.push(m[1])
                }
            }
        }
        var b = e.toString().replace(/"use strict";\n\n/, ""), k = b.replace(/^function\s?\((.*)\)(\s?)\{(\n"use strict";\n)?/, "function($1)$2{"), R = b.replace(/^function\s?\((.*)\)(\s?)\{(\n"use strict";\n)?/, "function ($1)$2{"), l = d.find(function (t) {
            var r = a[t].toString();
            if (r.indexOf(k) > -1 || r.indexOf(R) > -1) {
                var n = i(t);
                return (!n || n !== e && n.default !== e) && (u[t] = r.substring(0, r.length - 1) + "\n" + b.match(/function\s?(.+?)\s?\(.*/)[1] + "();\n}"), !0
            }
            return !1
        });
        if ("undefined" == typeof l)throw new Error("webworkify-webpack: Could not locate module containing worker function! Make sure you aren't using eval sourcemaps and that you pass named functions to webworkify-webpack!");
        var _ = "window = {};\nvar fn = (" + o.toString().replace("entryModule", l) + ")([" + u.join(",") + ']);\n(typeof fn === "function") && fn(self);', S = new Blob([_], {type: "text/javascript"});
        if (t && t.bare)return S;
        var T = window.URL || window.webkitURL || window.mozURL || window.msURL, A = T.createObjectURL(S), L = new Worker(A);
        return L.objectURL = A, L
    }
}, function (e, t, r) {
    var i = r(13);
    i(flowplayer)
}]);
/*@
 @end
 @*/
